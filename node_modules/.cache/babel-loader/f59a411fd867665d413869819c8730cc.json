{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { padLeftZeros, insertAt } from './strings';\n\nvar MaskFormat = function () {\n  function MaskFormat(_a) {\n    var separator = _a.separator,\n        _b = _a.inputSeparators,\n        inputSeparators = _b === void 0 ? [] : _b,\n        segments = _a.segments;\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n    this.inputSeparators = __spreadArray(__spreadArray([], inputSeparators, true), [separator], false);\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  MaskFormat.prototype.tryAppendSeparator = function (value) {\n    var withSeparator = \"\" + value + this.separator;\n    return this.isValid(withSeparator) ? withSeparator : value;\n  };\n\n  MaskFormat.prototype.isSeparator = function (key) {\n    return this.inputSeparators.indexOf(key) !== -1;\n  };\n\n  MaskFormat.prototype.isValid = function (value) {\n    var _this = this;\n\n    var inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every(function (segmentValue, i) {\n      var segment = _this.segments[i];\n\n      if (segmentValue === '') {\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n\n      var intValue = parseInt(segmentValue, 10);\n\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  };\n\n  MaskFormat.prototype.getValidValue = function (value) {\n    var validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  };\n\n  MaskFormat.prototype.autoComplete = function (value) {\n    var _a = value.split(this.separator).reverse(),\n        lastSegmentValue = _a[0],\n        completeSegmentValues = _a.slice(1);\n\n    var lastSegment = this.segments[completeSegmentValues.length];\n    var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n\n    var partial = __spreadArray(__spreadArray([], completeSegmentValues.reverse(), true), [paddedLastSegmentValue], false);\n\n    while (partial.length < this.segments.length) {\n      var nextSegment = this.segments[partial.length];\n      var segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  };\n\n  MaskFormat.prototype.getSegmentValueWithAddition = function (position, value, enteredDigit) {\n    var segment = this.positionFormats[position];\n    var segmentValue = value.substr(segment.start, segment.length);\n    var segmentPosition = position - segment.start;\n    var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  };\n\n  MaskFormat.prototype.replaceDigitsWithZeroes = function (value, cursorStart, cursorEnd) {\n    var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n\n    if (!this.isSegmentStart(cursorStart)) {\n      var segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n\n    var currentSegment;\n\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.handleSeparatorInput = function (value, position) {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      var segment = this.positionFormats[position];\n      var segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value: value,\n        position: value.length\n      };\n    }\n  };\n\n  MaskFormat.prototype.isCursorAtSeparator = function (position) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  };\n\n  MaskFormat.prototype.isSegmentStart = function (position) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  };\n\n  MaskFormat.prototype.getSegmentMaxValue = function (value, position) {\n    return this.positionFormats[position].max(value);\n  };\n\n  MaskFormat.prototype.getSegmentMinValue = function (value, position) {\n    return this.positionFormats[position].min;\n  };\n\n  MaskFormat.prototype.getMaxLength = function () {\n    var last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  };\n\n  MaskFormat.prototype.deleteSeparator = function (value, position) {\n    value = insertAt(value, '0', position - 2, position - 1);\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2\n    };\n  };\n\n  MaskFormat.prototype.deleteDigit = function (value, position) {\n    value = insertAt(value, '0', position - 1, position);\n    var length = value.length;\n\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1\n    };\n  };\n\n  MaskFormat.prototype.correctMinMaxValues = function (value) {\n    var segment = this.positionFormats[0];\n\n    while (segment && value.length >= segment.end) {\n      var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      var segmentMax = segment.max(value);\n\n      if (segmentValue < segment.min) {\n        var toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n\n      segment = this.positionFormats[segment.end + 1];\n    }\n\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  };\n\n  MaskFormat.prototype.formatPastedText = function (text, value, cursorStart, cursorEnd) {\n    var keyArr = text.trim().split('');\n    var position = cursorStart;\n    var formattedValue = value;\n\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {\n      var key = keyArr_1[_i];\n\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      var result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  };\n\n  MaskFormat.prototype.processKey = function (initialValue, key, initialPosition) {\n    var value = initialValue;\n    var position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      var result = this.handleSeparatorInput(value, position);\n\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      var isCursorAtEnd = position === value.length;\n      var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      var segmentMaxValue = this.getSegmentMaxValue(value, position);\n      var segmentMinValue = this.getSegmentMinValue(value, position);\n      var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        value = insertAt(value, \"0\" + key, position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value);\n\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.padWithDefaultValue = function (segmentValue, segment) {\n    var defaultValue = (segment[\"default\"] || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  };\n\n  MaskFormat.prototype.enrichSegmentDefinitions = function (segments) {\n    this.positionFormats = {};\n    this.segments = [];\n    var position = 0;\n\n    var _loop_1 = function (segment) {\n      var max = segment.max;\n\n      var fullSegment = __assign(__assign({}, segment), {\n        max: typeof max === 'number' ? function () {\n          return max;\n        } : max,\n        start: position,\n        end: position + segment.length\n      });\n\n      this_1.segments.push(fullSegment);\n\n      for (var j = 0; j < fullSegment.length; j++) {\n        this_1.positionFormats[position++] = fullSegment;\n      }\n\n      position++;\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n      var segment = segments_1[_i];\n\n      _loop_1(segment);\n    }\n  };\n\n  return MaskFormat;\n}();\n\nexport default MaskFormat;","map":{"version":3,"sources":["/Users/isingheg/Desktop/projects/amazonforvolunteers-ui/node_modules/@awsui/components-react/internal/components/masked-input/utils/mask-format.js"],"names":["__assign","__spreadArray","padLeftZeros","insertAt","MaskFormat","_a","separator","_b","inputSeparators","segments","positionFormats","enrichSegmentDefinitions","prototype","tryAppendSeparator","value","withSeparator","isValid","isSeparator","key","indexOf","_this","inputSegments","split","length","every","segmentValue","i","segment","match","intValue","parseInt","min","max","getValidValue","validValue","substring","autoComplete","reverse","lastSegmentValue","completeSegmentValues","slice","lastSegment","paddedLastSegmentValue","padWithDefaultValue","partial","nextSegment","push","join","correctMinMaxValues","getSegmentValueWithAddition","position","enteredDigit","substr","start","segmentPosition","newValue","replaceDigitsWithZeroes","cursorStart","cursorEnd","isCursorAtSeparator","isSegmentStart","end","currentSegment","insertionEnd","Math","handleSeparatorInput","getMaxLength","undefined","getSegmentMaxValue","getSegmentMinValue","last","deleteSeparator","deleteDigit","segmentMax","toInsert","toFixed","formatPastedText","text","keyArr","trim","formattedValue","_i","keyArr_1","result","processKey","initialValue","initialPosition","isCursorAtEnd","segmentMaxValue","segmentMinValue","firstDigitGreater","isValidPosition","exceedsMaxAtSegmentStart","defaultValue","_loop_1","fullSegment","this_1","j","segments_1"],"mappings":"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","sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nimport { padLeftZeros, insertAt } from './strings';\nvar MaskFormat = (function () {\n    function MaskFormat(_a) {\n        var separator = _a.separator, _b = _a.inputSeparators, inputSeparators = _b === void 0 ? [] : _b, segments = _a.segments;\n        this.positionFormats = {};\n        this.segments = [];\n        this.separator = separator;\n        this.inputSeparators = __spreadArray(__spreadArray([], inputSeparators, true), [separator], false);\n        this.enrichSegmentDefinitions(segments);\n    }\n    MaskFormat.prototype.tryAppendSeparator = function (value) {\n        var withSeparator = \"\" + value + this.separator;\n        return this.isValid(withSeparator) ? withSeparator : value;\n    };\n    MaskFormat.prototype.isSeparator = function (key) {\n        return this.inputSeparators.indexOf(key) !== -1;\n    };\n    MaskFormat.prototype.isValid = function (value) {\n        var _this = this;\n        var inputSegments = value.split(this.separator);\n        if (inputSegments.length > this.segments.length) {\n            return false;\n        }\n        return inputSegments.every(function (segmentValue, i) {\n            var segment = _this.segments[i];\n            if (segmentValue === '') {\n                if (i === inputSegments.length - 1) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            if (!segmentValue.match(/^\\d+$/)) {\n                return false;\n            }\n            if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n                return false;\n            }\n            var intValue = parseInt(segmentValue, 10);\n            if (segmentValue.length > segment.length) {\n                return false;\n            }\n            if (intValue < segment.min || intValue > segment.max(value)) {\n                if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n                    return true;\n                }\n                return false;\n            }\n            return true;\n        });\n    };\n    MaskFormat.prototype.getValidValue = function (value) {\n        var validValue = value;\n        do {\n            if (this.isValid(validValue)) {\n                return this.tryAppendSeparator(validValue);\n            }\n            validValue = validValue.substring(0, validValue.length - 1);\n        } while (validValue.length > 0);\n        return '';\n    };\n    MaskFormat.prototype.autoComplete = function (value) {\n        var _a = value.split(this.separator).reverse(), lastSegmentValue = _a[0], completeSegmentValues = _a.slice(1);\n        var lastSegment = this.segments[completeSegmentValues.length];\n        var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n        var partial = __spreadArray(__spreadArray([], completeSegmentValues.reverse(), true), [paddedLastSegmentValue], false);\n        while (partial.length < this.segments.length) {\n            var nextSegment = this.segments[partial.length];\n            var segmentValue = this.padWithDefaultValue('', nextSegment);\n            partial.push(segmentValue);\n        }\n        value = partial.join(this.separator);\n        value = this.correctMinMaxValues(value);\n        return value;\n    };\n    MaskFormat.prototype.getSegmentValueWithAddition = function (position, value, enteredDigit) {\n        var segment = this.positionFormats[position];\n        var segmentValue = value.substr(segment.start, segment.length);\n        var segmentPosition = position - segment.start;\n        var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n        return parseInt(newValue, 10);\n    };\n    MaskFormat.prototype.replaceDigitsWithZeroes = function (value, cursorStart, cursorEnd) {\n        var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n        if (this.isCursorAtSeparator(cursorStart)) {\n            cursorStart++;\n        }\n        if (!this.isSegmentStart(cursorStart)) {\n            var segment = this.positionFormats[cursorStart];\n            value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n            cursorStart = segment.end + 1;\n        }\n        var currentSegment;\n        while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n            var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n            value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n            cursorStart = insertionEnd + 1;\n        }\n        value = this.correctMinMaxValues(value);\n        return {\n            value: value,\n            position: position\n        };\n    };\n    MaskFormat.prototype.handleSeparatorInput = function (value, position) {\n        if (position === value.length && !this.isSegmentStart(position)) {\n            var segment = this.positionFormats[position];\n            var segmentValue = value.substr(segment.start, segment.length);\n            segmentValue = this.padWithDefaultValue(segmentValue, segment);\n            value = insertAt(value, segmentValue, segment.start, segment.end);\n            value = this.correctMinMaxValues(value);\n            return {\n                value: value,\n                position: value.length\n            };\n        }\n    };\n    MaskFormat.prototype.isCursorAtSeparator = function (position) {\n        return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n    };\n    MaskFormat.prototype.isSegmentStart = function (position) {\n        return position === 0 || this.isCursorAtSeparator(position - 1);\n    };\n    MaskFormat.prototype.getSegmentMaxValue = function (value, position) {\n        return this.positionFormats[position].max(value);\n    };\n    MaskFormat.prototype.getSegmentMinValue = function (value, position) {\n        return this.positionFormats[position].min;\n    };\n    MaskFormat.prototype.getMaxLength = function () {\n        var last = this.segments[this.segments.length - 1];\n        return last.start + last.length;\n    };\n    MaskFormat.prototype.deleteSeparator = function (value, position) {\n        value = insertAt(value, '0', position - 2, position - 1);\n        return {\n            value: this.correctMinMaxValues(value),\n            position: position - 2\n        };\n    };\n    MaskFormat.prototype.deleteDigit = function (value, position) {\n        value = insertAt(value, '0', position - 1, position);\n        var length = value.length;\n        if (value.slice(length - 2) === '0:') {\n            value = value.slice(0, length - 2);\n        }\n        return {\n            value: this.correctMinMaxValues(value),\n            position: position - 1\n        };\n    };\n    MaskFormat.prototype.correctMinMaxValues = function (value) {\n        var segment = this.positionFormats[0];\n        while (segment && value.length >= segment.end) {\n            var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n            var segmentMax = segment.max(value);\n            if (segmentValue < segment.min) {\n                var toInsert = segment.min.toFixed();\n                toInsert = padLeftZeros(toInsert, segment.length);\n                value = insertAt(value, toInsert, segment.start, segment.end);\n            }\n            if (segmentValue > segmentMax) {\n                value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n            }\n            segment = this.positionFormats[segment.end + 1];\n        }\n        return value.substr(0, this.segments[this.segments.length - 1].end);\n    };\n    MaskFormat.prototype.formatPastedText = function (text, value, cursorStart, cursorEnd) {\n        var keyArr = text.trim().split('');\n        var position = cursorStart;\n        var formattedValue = value;\n        if (cursorEnd > cursorStart && cursorEnd === value.length) {\n            formattedValue = value.slice(0, cursorStart);\n        }\n        for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {\n            var key = keyArr_1[_i];\n            if (position >= this.getMaxLength()) {\n                break;\n            }\n            var result = this.processKey(formattedValue, key, position);\n            formattedValue = result.value;\n            position = result.position;\n        }\n        return this.tryAppendSeparator(formattedValue);\n    };\n    MaskFormat.prototype.processKey = function (initialValue, key, initialPosition) {\n        var value = initialValue;\n        var position = initialPosition;\n        if (this.isSeparator(key)) {\n            var result = this.handleSeparatorInput(value, position);\n            if (result) {\n                value = result.value;\n                position = result.position;\n            }\n        }\n        else {\n            var isCursorAtEnd = position === value.length;\n            var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n            var segmentMaxValue = this.getSegmentMaxValue(value, position);\n            var segmentMinValue = this.getSegmentMinValue(value, position);\n            var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n            var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n            var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n            if (exceedsMaxAtSegmentStart) {\n                value = insertAt(value, \"0\" + key, position, position + 2);\n                position += 2;\n            }\n            else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n                value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n                position += segmentMaxValue.toFixed().length;\n            }\n            else if (segmentValue > segmentMaxValue) {\n                value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n                position += 1;\n            }\n            else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n                value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n                position += 1;\n            }\n            else {\n                value = insertAt(value, key, position, position + 1);\n                position += 1;\n            }\n        }\n        value = this.tryAppendSeparator(value);\n        if (this.isCursorAtSeparator(position)) {\n            position++;\n        }\n        return { value: value, position: position };\n    };\n    MaskFormat.prototype.padWithDefaultValue = function (segmentValue, segment) {\n        var defaultValue = (segment[\"default\"] || segment.min).toFixed();\n        defaultValue = padLeftZeros(defaultValue, segment.length);\n        return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n    };\n    MaskFormat.prototype.enrichSegmentDefinitions = function (segments) {\n        this.positionFormats = {};\n        this.segments = [];\n        var position = 0;\n        var _loop_1 = function (segment) {\n            var max = segment.max;\n            var fullSegment = __assign(__assign({}, segment), { max: typeof max === 'number' ? function () { return max; } : max, start: position, end: position + segment.length });\n            this_1.segments.push(fullSegment);\n            for (var j = 0; j < fullSegment.length; j++) {\n                this_1.positionFormats[position++] = fullSegment;\n            }\n            position++;\n        };\n        var this_1 = this;\n        for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n            var segment = segments_1[_i];\n            _loop_1(segment);\n        }\n    };\n    return MaskFormat;\n}());\nexport default MaskFormat;\n"]},"metadata":{},"sourceType":"module"}