{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nexport var chartLegendMap = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed'\n};\nexport function computeDomainX(series, xScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce(function (acc, s) {\n      if (s.series.type !== 'threshold') {\n        s.series.data.forEach(function (_a) {\n          var x = _a.x;\n\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n\n      return acc;\n    }, []);\n  }\n\n  return series.reduce(function (acc, curr) {\n    if (curr.series.type === 'threshold') {\n      return acc;\n    }\n\n    return curr.series.data.reduce(function (_a, _b) {\n      var min = _a[0],\n          max = _a[1];\n      var x = _b.x;\n      var newMin = min === undefined || x < min ? x : min;\n      var newMax = max === undefined || max < x ? x : max;\n      return [newMin, newMax];\n    }, acc);\n  }, []);\n}\n\nfunction find(arr, func) {\n  for (var i = 0; i < arr.length; i++) {\n    var found = func(arr[i]);\n\n    if (found) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nexport function computeDomainY(series, scaleType, stackedBars) {\n  var _series = series;\n\n  if (stackedBars) {\n    var _a = series.reduce(function (acc, curr) {\n      if (curr.series.type === 'bar') {\n        curr.series.data.forEach(function (_a) {\n          var x = _a.x,\n              y = _a.y;\n          var data = y < 0 ? acc.negativeData : acc.positiveData;\n          var stackedDatum = find(data, function (el) {\n            return matchesX(el.x, x);\n          });\n\n          if (stackedDatum) {\n            stackedDatum.y += y;\n          } else {\n            data.push({\n              x: x,\n              y: y\n            });\n          }\n\n          return acc;\n        });\n      }\n\n      return acc;\n    }, {\n      positiveData: [],\n      negativeData: []\n    }),\n        positiveData = _a.positiveData,\n        negativeData = _a.negativeData;\n\n    var stackedSeries = [{\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'positive',\n        data: positiveData\n      }\n    }, {\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'negative',\n        data: negativeData\n      }\n    }];\n    _series = __spreadArray(__spreadArray([], stackedSeries, true), _series.filter(function (s) {\n      return s.series.type !== 'bar';\n    }), true);\n  }\n\n  var domain = _series.reduce(function (acc, curr) {\n    if (curr.series.type === 'threshold') {\n      var min = acc[0],\n          max = acc[1];\n      var y = curr.series.y;\n      var newMin = min === undefined || y < min ? y : min;\n      var newMax = max === undefined || max < y ? y : max;\n      return [newMin, newMax];\n    }\n\n    return curr.series.data.reduce(function (_a, _b) {\n      var min = _a[0],\n          max = _a[1];\n      var y = _b.y;\n      var newMin = min === undefined || y < min ? y : min;\n      var newMax = max === undefined || max < y ? y : max;\n      return [newMin, newMax];\n    }, acc);\n  }, [0, 0]);\n\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n\n  return domain;\n}\nexport var nextValidDomainIndex = function (nextGroupIndex, barGroups, direction) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  var index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n\n    index += direction;\n\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n\n  return 0;\n};\nexport function findNavigableSeries(series) {\n  var navigableSeries = [];\n  var navigableBarSeriesIndex = -1;\n  series.forEach(function (internalSeries) {\n    if (internalSeries.series.type === 'bar') {\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return {\n    navigableSeries: navigableSeries,\n    navigableBarSeriesIndex: navigableBarSeriesIndex\n  };\n}\nexport var matchesX = function (x1, x2) {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n\n  return x1 === x2;\n};\nexport function calculateOffsetMaps(data) {\n  return data.reduce(function (acc, curr, idx) {\n    if (idx === 0) {\n      acc.push({\n        positiveOffsets: {},\n        negativeOffsets: {}\n      });\n    }\n\n    var lastMap = acc[idx];\n    var map = lastMap ? {\n      positiveOffsets: __assign({}, lastMap.positiveOffsets),\n      negativeOffsets: __assign({}, lastMap.negativeOffsets)\n    } : {\n      positiveOffsets: {},\n      negativeOffsets: {}\n    };\n    curr.forEach(function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var key = getKeyValue(x);\n\n      if (y < 0) {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    });\n\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, []);\n}\nexport var getKeyValue = function (key) {\n  return key instanceof Date ? key.getTime() : key;\n};","map":{"version":3,"sources":["/Users/isingheg/Desktop/projects/amazonforvolunteers-ui/node_modules/@awsui/components-react/mixed-line-bar-chart/utils.js"],"names":["__assign","__spreadArray","chartLegendMap","line","bar","threshold","computeDomainX","series","xScaleType","reduce","acc","s","type","data","forEach","_a","x","indexOf","push","curr","_b","min","max","newMin","undefined","newMax","find","arr","func","i","length","found","computeDomainY","scaleType","stackedBars","_series","y","negativeData","positiveData","stackedDatum","el","matchesX","stackedSeries","color","index","NaN","title","filter","domain","nextValidDomainIndex","nextGroupIndex","barGroups","direction","isValid","hasData","findNavigableSeries","navigableSeries","navigableBarSeriesIndex","internalSeries","x1","x2","Date","getTime","calculateOffsetMaps","idx","positiveOffsets","negativeOffsets","lastMap","map","key","getKeyValue","lastValue"],"mappings":"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","sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nexport var chartLegendMap = {\n    line: 'line',\n    bar: 'rectangle',\n    threshold: 'dashed'\n};\nexport function computeDomainX(series, xScaleType) {\n    if (xScaleType === 'categorical') {\n        return series.reduce(function (acc, s) {\n            if (s.series.type !== 'threshold') {\n                s.series.data.forEach(function (_a) {\n                    var x = _a.x;\n                    if (acc.indexOf(x) === -1) {\n                        acc.push(x);\n                    }\n                });\n            }\n            return acc;\n        }, []);\n    }\n    return series.reduce(function (acc, curr) {\n        if (curr.series.type === 'threshold') {\n            return acc;\n        }\n        return curr.series.data.reduce(function (_a, _b) {\n            var min = _a[0], max = _a[1];\n            var x = _b.x;\n            var newMin = min === undefined || x < min ? x : min;\n            var newMax = max === undefined || max < x ? x : max;\n            return [newMin, newMax];\n        }, acc);\n    }, []);\n}\nfunction find(arr, func) {\n    for (var i = 0; i < arr.length; i++) {\n        var found = func(arr[i]);\n        if (found) {\n            return arr[i];\n        }\n    }\n    return null;\n}\nexport function computeDomainY(series, scaleType, stackedBars) {\n    var _series = series;\n    if (stackedBars) {\n        var _a = series.reduce(function (acc, curr) {\n            if (curr.series.type === 'bar') {\n                curr.series.data.forEach(function (_a) {\n                    var x = _a.x, y = _a.y;\n                    var data = y < 0 ? acc.negativeData : acc.positiveData;\n                    var stackedDatum = find(data, function (el) { return matchesX(el.x, x); });\n                    if (stackedDatum) {\n                        stackedDatum.y += y;\n                    }\n                    else {\n                        data.push({ x: x, y: y });\n                    }\n                    return acc;\n                });\n            }\n            return acc;\n        }, {\n            positiveData: [],\n            negativeData: []\n        }), positiveData = _a.positiveData, negativeData = _a.negativeData;\n        var stackedSeries = [\n            {\n                color: '',\n                index: NaN,\n                series: {\n                    type: 'bar',\n                    title: 'positive',\n                    data: positiveData\n                }\n            },\n            {\n                color: '',\n                index: NaN,\n                series: {\n                    type: 'bar',\n                    title: 'negative',\n                    data: negativeData\n                }\n            },\n        ];\n        _series = __spreadArray(__spreadArray([], stackedSeries, true), _series.filter(function (s) { return s.series.type !== 'bar'; }), true);\n    }\n    var domain = _series.reduce(function (acc, curr) {\n        if (curr.series.type === 'threshold') {\n            var min = acc[0], max = acc[1];\n            var y = curr.series.y;\n            var newMin = min === undefined || y < min ? y : min;\n            var newMax = max === undefined || max < y ? y : max;\n            return [newMin, newMax];\n        }\n        return curr.series.data.reduce(function (_a, _b) {\n            var min = _a[0], max = _a[1];\n            var y = _b.y;\n            var newMin = min === undefined || y < min ? y : min;\n            var newMax = max === undefined || max < y ? y : max;\n            return [newMin, newMax];\n        }, acc);\n    }, [0, 0]);\n    if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n        return [1, domain[1]];\n    }\n    return domain;\n}\nexport var nextValidDomainIndex = function (nextGroupIndex, barGroups, direction) {\n    if (direction === void 0) { direction = 1; }\n    var index = nextGroupIndex;\n    if (index < 0 || index >= barGroups.length) {\n        index = 0;\n    }\n    do {\n        if (barGroups[index].isValid && barGroups[index].hasData) {\n            return index;\n        }\n        index += direction;\n        if (index >= barGroups.length) {\n            index = 0;\n        }\n        else if (index < 0) {\n            index = barGroups.length - 1;\n        }\n    } while (index !== nextGroupIndex);\n    return 0;\n};\nexport function findNavigableSeries(series) {\n    var navigableSeries = [];\n    var navigableBarSeriesIndex = -1;\n    series.forEach(function (internalSeries) {\n        if (internalSeries.series.type === 'bar') {\n            if (navigableBarSeriesIndex === -1) {\n                navigableBarSeriesIndex = navigableSeries.length;\n                navigableSeries.push(internalSeries.series);\n            }\n        }\n        else {\n            navigableSeries.push(internalSeries.series);\n        }\n    });\n    return { navigableSeries: navigableSeries, navigableBarSeriesIndex: navigableBarSeriesIndex };\n}\nexport var matchesX = function (x1, x2) {\n    if (x1 instanceof Date && x2 instanceof Date) {\n        return x1.getTime() === x2.getTime();\n    }\n    return x1 === x2;\n};\nexport function calculateOffsetMaps(data) {\n    return data.reduce(function (acc, curr, idx) {\n        if (idx === 0) {\n            acc.push({ positiveOffsets: {}, negativeOffsets: {} });\n        }\n        var lastMap = acc[idx];\n        var map = lastMap\n            ? { positiveOffsets: __assign({}, lastMap.positiveOffsets), negativeOffsets: __assign({}, lastMap.negativeOffsets) }\n            : { positiveOffsets: {}, negativeOffsets: {} };\n        curr.forEach(function (_a) {\n            var x = _a.x, y = _a.y;\n            var key = getKeyValue(x);\n            if (y < 0) {\n                var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;\n                map.negativeOffsets[key] = lastValue + y;\n            }\n            else {\n                var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;\n                map.positiveOffsets[key] = lastValue + y;\n            }\n        });\n        if (idx < data.length - 1) {\n            acc.push(map);\n        }\n        return acc;\n    }, []);\n}\nexport var getKeyValue = function (key) { return (key instanceof Date ? key.getTime() : key); };\n"]},"metadata":{},"sourceType":"module"}