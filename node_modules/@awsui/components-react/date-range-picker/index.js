import { __assign, __rest } from "tslib";
import React, { useEffect, useRef, useState } from 'react';
import styles from './styles.css.js';
import { normalizeLocale } from '../date-picker/calendar/utils/locales';
import { getWeekStartByLocale } from 'weekstart';
import useForwardFocus from '../internal/hooks/forward-focus';
import { KeyCode } from '../internal/keycode';
import clsx from 'clsx';
import { getBaseProps } from '../internal/base-component';
import checkControlled from '../internal/hooks/check-controlled';
import InternalBox from '../box/internal';
import { DateRangePickerDropdown } from './dropdown';
import { applyDisplayName } from '../internal/utils/apply-display-name';
import Dropdown from '../internal/components/dropdown';
import { useFocusTracker } from '../internal/hooks/use-focus-tracker';
import { useMobile } from '../internal/hooks/use-mobile';
import ButtonTrigger from '../internal/components/button-trigger';
import { useFormFieldContext } from '../internal/context/form-field-context';
import InternalIcon from '../icon/internal';
import { getBrowserTimezoneOffset, shiftTimeOffset, formatOffset, setTimeOffset } from './time-offset';
import useBaseComponent from '../internal/hooks/use-base-component';
import mergeRefs from 'react-merge-refs';
import { fireNonCancelableEvent } from '../internal/events/index.js';
import { isDevelopment } from '../internal/is-development.js';
import { warnOnce } from '../internal/logging.js';
import { usePrevious } from '../internal/hooks/use-previous/index.js';
import { useUniqueId } from '../internal/hooks/use-unique-id';
function formatDateRange(range, placeholder, formatRelativeRange, timeOffset) {
    if (!range) {
        return (React.createElement("span", { className: styles['label-text'], "aria-disabled": true }, placeholder));
    }
    if (range.type === 'relative') {
        return (React.createElement(InternalBox, { fontWeight: "normal", display: "inline", color: "inherit" }, formatRelativeRange(range)));
    }
    if (range.type === 'absolute') {
        var formattedOffset = isDateOnly(range) ? '' : formatOffset(timeOffset);
        return (React.createElement(InternalBox, { fontWeight: "normal", display: "inline", color: "inherit" },
            React.createElement("span", { className: styles['preferred-wordbreak'] },
                range.startDate,
                formattedOffset,
                " \u2014"),
            ' ',
            React.createElement("span", { className: styles['preferred-wordbreak'] },
                range.endDate,
                formattedOffset)));
    }
}
function isDateOnly(value) {
    if (!value || value.type !== 'absolute') {
        return false;
    }
    var dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    return dateRegex.test(value.startDate) && dateRegex.test(value.endDate);
}
function formatValue(value, _a) {
    var timeOffset = _a.timeOffset, dateOnly = _a.dateOnly;
    if (!value || value.type === 'relative') {
        return value;
    }
    if (dateOnly) {
        return {
            type: 'absolute',
            startDate: value.startDate.split('T')[0],
            endDate: value.endDate.split('T')[0]
        };
    }
    return setTimeOffset(value, timeOffset);
}
var DateRangePicker = React.forwardRef(function (_a, ref) {
    var _b;
    var _c = _a.locale, locale = _c === void 0 ? '' : _c, startOfWeek = _a.startOfWeek, _d = _a.isDateEnabled, isDateEnabled = _d === void 0 ? function () { return true; } : _d, value = _a.value, placeholder = _a.placeholder, _e = _a.readOnly, readOnly = _e === void 0 ? false : _e, _f = _a.disabled, disabled = _f === void 0 ? false : _f, onChange = _a.onChange, onBlur = _a.onBlur, onFocus = _a.onFocus, _g = _a.relativeOptions, relativeOptions = _g === void 0 ? [] : _g, i18nStrings = _a.i18nStrings, _h = _a.isValidRange, isValidRange = _h === void 0 ? function () { return ({ valid: true }); } : _h, _j = _a.showClearButton, showClearButton = _j === void 0 ? true : _j, _k = _a.dateOnly, dateOnly = _k === void 0 ? false : _k, _l = _a.timeOffset, timeOffset = _l === void 0 ? getBrowserTimezoneOffset() : _l, _m = _a.timeInputFormat, timeInputFormat = _m === void 0 ? 'hh:mm:ss' : _m, _o = _a.expandToViewport, expandToViewport = _o === void 0 ? false : _o, _p = _a.rangeSelectorMode, rangeSelectorMode = _p === void 0 ? 'default' : _p, rest = __rest(_a, ["locale", "startOfWeek", "isDateEnabled", "value", "placeholder", "readOnly", "disabled", "onChange", "onBlur", "onFocus", "relativeOptions", "i18nStrings", "isValidRange", "showClearButton", "dateOnly", "timeOffset", "timeInputFormat", "expandToViewport", "rangeSelectorMode"]);
    var __internalRootRef = useBaseComponent('DateRangePicker').__internalRootRef;
    checkControlled('DateRangePicker', 'value', value, 'onChange', onChange);
    value = isDateOnly(value) ? value : shiftTimeOffset(value, timeOffset);
    var baseProps = getBaseProps(rest);
    var _q = useFormFieldContext(rest), invalid = _q.invalid, controlId = _q.controlId, ariaDescribedby = _q.ariaDescribedby, ariaLabelledby = _q.ariaLabelledby;
    var isSingleGrid = useMobile();
    var triggerRef = useRef(null);
    useForwardFocus(ref, triggerRef);
    var rootRef = useRef(null);
    var dropdownId = useUniqueId('date-range-picker-dropdown');
    useFocusTracker({ rootRef: rootRef, onBlur: onBlur, onFocus: onFocus, viewportId: expandToViewport ? dropdownId : '' });
    var _r = useState(false), isDropDownOpen = _r[0], setIsDropDownOpen = _r[1];
    var normalizedLocale = normalizeLocale('DateRangePicker', locale !== null && locale !== void 0 ? locale : '');
    var normalizedStartOfWeek = (typeof startOfWeek === 'number' ? startOfWeek % 7 : getWeekStartByLocale(normalizedLocale));
    var closeDropdown = function (focusTrigger) {
        var _a;
        if (focusTrigger === void 0) { focusTrigger = false; }
        setIsDropDownOpen(false);
        if (focusTrigger) {
            (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    };
    var onWrapperKeyDownHandler = function (event) {
        if (event.keyCode === KeyCode.escape) {
            closeDropdown(true);
        }
    };
    var onClear = function () {
        fireNonCancelableEvent(onChange, { value: null });
    };
    var onApply = function (newValue) {
        var validationResult = isValidRange(newValue);
        if ((validationResult === null || validationResult === void 0 ? void 0 : validationResult.valid) === false) {
            return validationResult;
        }
        var value = newValue;
        if (isDevelopment) {
            if ((newValue === null || newValue === void 0 ? void 0 : newValue.type) === 'absolute') {
                var startDateWithoutTime = newValue.startDate.split('T')[0];
                var endDateWithoutTime = newValue.endDate.split('T')[0];
                if (!startDateWithoutTime || !endDateWithoutTime) {
                    value = null;
                    warnOnce('DateRangePicker', 'You have provided an `isValidRange` prop that did not catch a missing start or end date. This component will fall back to returning a `null` value instead of an incomplete one.');
                }
            }
        }
        fireNonCancelableEvent(onChange, { value: formatValue(value, { dateOnly: dateOnly, timeOffset: timeOffset }) });
        return validationResult || { valid: true };
    };
    var prevDateOnly = usePrevious(dateOnly);
    useEffect(function () {
        if (prevDateOnly !== undefined && prevDateOnly !== dateOnly) {
            warnOnce('DateRangePicker', "The provided `dateOnly` flag has been changed from \"" + prevDateOnly + "\" to \"" + dateOnly + "\" which can lead to unexpected value format. Consider using separate components.");
        }
    }, [prevDateOnly, dateOnly]);
    if (value && value.type !== 'absolute' && value.type !== 'relative') {
        warnOnce('DateRangePicker', 'You provided an invalid value. Reverting back to default.');
        value = null;
    }
    if (((value === null || value === void 0 ? void 0 : value.type) === 'absolute' && rangeSelectorMode === 'relative-only') ||
        ((value === null || value === void 0 ? void 0 : value.type) === 'relative' && rangeSelectorMode === 'absolute-only')) {
        warnOnce('DateRangePicker', 'The provided value does not correspond to the current range selector mode. Reverting back to default.');
        value = null;
    }
    var trigger = (React.createElement("div", { className: styles['trigger-wrapper'] },
        React.createElement(ButtonTrigger, { ref: triggerRef, id: controlId, invalid: invalid, ariaDescribedby: ariaDescribedby, ariaLabelledby: ariaLabelledby, className: clsx(styles.label, (_b = {},
                _b[styles['label-enabled']] = !readOnly && !disabled,
                _b)), hideCaret: true, onClick: function () {
                if (!readOnly && !disabled) {
                    setIsDropDownOpen(true);
                }
            }, disabled: disabled, readOnly: readOnly, ariaHasPopup: "true" },
            React.createElement("span", { className: styles['trigger-flexbox'] },
                React.createElement("span", { className: styles['icon-wrapper'] },
                    React.createElement(InternalIcon, { name: "calendar", variant: disabled || readOnly ? 'disabled' : 'normal' })),
                formatDateRange(value, placeholder !== null && placeholder !== void 0 ? placeholder : '', i18nStrings.formatRelativeRange, timeOffset)))));
    return (React.createElement("div", __assign({}, baseProps, { ref: mergeRefs([rootRef, __internalRootRef]), className: clsx(baseProps.className, styles.root), onKeyDown: onWrapperKeyDownHandler }),
        React.createElement(Dropdown, { stretchWidth: true, stretchHeight: true, open: isDropDownOpen, onDropdownClose: function () { return closeDropdown(); }, trigger: trigger, stretchToTriggerWidth: false, expandToViewport: expandToViewport, dropdownId: dropdownId }, isDropDownOpen && (React.createElement(DateRangePickerDropdown, { startOfWeek: normalizedStartOfWeek, locale: normalizedLocale, isSingleGrid: isSingleGrid, onDropdownClose: function () { return closeDropdown(true); }, value: value, showClearButton: showClearButton, isDateEnabled: isDateEnabled, i18nStrings: i18nStrings, onClear: onClear, onApply: onApply, relativeOptions: relativeOptions, isValidRange: isValidRange, dateOnly: dateOnly, timeInputFormat: timeInputFormat, rangeSelectorMode: rangeSelectorMode })))));
});
applyDisplayName(DateRangePicker, 'DateRangePicker');
export default DateRangePicker;
