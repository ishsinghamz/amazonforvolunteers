import { padLeftZeros } from '../internal/components/masked-input/utils/strings';
import { addMinutes } from 'date-fns';
import { formatTime, formatDate } from '../date-picker/calendar/utils/date';
import { warnOnce } from '../internal/logging';
export function getBrowserTimezoneOffset() {
    return 0 - new Date().getTimezoneOffset();
}
export function setTimeOffset(value, timeOffsetInMinutes) {
    if (!((value === null || value === void 0 ? void 0 : value.type) === 'absolute')) {
        return value;
    }
    var offsetSuffix = formatOffset(timeOffsetInMinutes);
    var startDate = value.startDate, endDate = value.endDate;
    return {
        type: 'absolute',
        startDate: startDate + offsetSuffix,
        endDate: endDate + offsetSuffix
    };
}
export function formatOffset(offsetInMinutes) {
    var hoursOffset = padLeftZeros(Math.floor(Math.abs(offsetInMinutes) / 60).toFixed(0), 2);
    var minuteOffset = padLeftZeros(Math.abs(offsetInMinutes % 60).toFixed(0), 2);
    var sign = offsetInMinutes < 0 ? '-' : '+';
    var offsetSuffix = "" + sign + hoursOffset + ":" + minuteOffset;
    return offsetSuffix;
}
export function shiftTimeOffset(value, timeOffsetInMinutes) {
    if (!value || value.type !== 'absolute') {
        return value;
    }
    var dateTimeRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2})?(\.\d{1,3})?(((\+|-)\d{2}(:\d{2})?)|Z)?$/;
    if (!dateTimeRegex.test(value.startDate) || !dateTimeRegex.test(value.endDate)) {
        warnOnce('DateRangePicker', 'You have provided a misformatted start or end date. The component will fall back to an empty value. ' +
            'Dates have to be ISO8601-formatted with an optional time zone offset.');
        return null;
    }
    return {
        type: 'absolute',
        startDate: doShiftTimeOffset(value.startDate, timeOffsetInMinutes),
        endDate: doShiftTimeOffset(value.endDate, timeOffsetInMinutes)
    };
}
function doShiftTimeOffset(value, targetOffsetInMinutes) {
    var _a = splitOffset(value), valueWithoutOffset = _a[0], offsetInMinutes = _a[1];
    var differenceBetweenValueAndTarget = targetOffsetInMinutes - offsetInMinutes;
    var date = new Date(valueWithoutOffset);
    var adjustedDate = addMinutes(date, differenceBetweenValueAndTarget);
    var formattedDate = formatDate(adjustedDate);
    var formattedTime = formatTime(adjustedDate);
    return formattedDate + "T" + formattedTime;
}
function splitOffset(value) {
    var _a = value.split('T'), datePart = _a[0], timePart = _a[1];
    var _b = timePart.split(/(-|\+)/), time = _b[0], signCharacter = _b[1], offsetPart = _b[2];
    if (signCharacter && offsetPart) {
        var _c = offsetPart.split(':'), offsetHours = _c[0], offsetMinutes = _c[1];
        var offset = Number(offsetHours) * 60 + Number(offsetMinutes);
        var sign = signCharacter === '-' ? -1 : 1;
        return [datePart + "T" + time, offset * sign];
    }
    var utcTimezoneIndicator = value.indexOf('Z');
    if (utcTimezoneIndicator !== -1) {
        return [value.substring(0, utcTimezoneIndicator), 0];
    }
    return [value, getBrowserTimezoneOffset()];
}
