import React, { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';
import { addMonths, endOfDay, isBefore, startOfDay, startOfMonth, isAfter, isSameMonth } from 'date-fns';
import styles from '../styles.css.js';
import CalendarHeader from './header';
import { Grids, selectFocusedDate } from './grids';
import moveFocusHandler from '../../date-picker/calendar/utils/move-focus-handler';
import { displayToIso, formatDate, formatTime, formatISOStringWithoutTimezone, isoToDisplay, parseDate, } from '../../date-picker/calendar/utils/date';
import InternalSpaceBetween from '../../space-between/internal';
import InternalFormField from '../../form-field/internal';
import DateInput from '../../internal/components/date-input';
import InternalTimeInput from '../../time-input/internal';
import clsx from 'clsx';
import { getBaseDate } from './get-base-date.js';
import { useUniqueId } from '../../internal/hooks/use-unique-id';
export default forwardRef(Calendar);
function Calendar(_a, ref) {
    var _b;
    var locale = _a.locale, startOfWeek = _a.startOfWeek, isDateEnabled = _a.isDateEnabled, onSelectDateRange = _a.onSelectDateRange, _c = _a.initialEndDate, initialEndDate = _c === void 0 ? '' : _c, _d = _a.initialStartDate, initialStartDate = _d === void 0 ? '' : _d, i18nStrings = _a.i18nStrings, dateOnly = _a.dateOnly, isSingleGrid = _a.isSingleGrid, timeInputFormat = _a.timeInputFormat;
    var elementRef = useRef(null);
    useImperativeHandle(ref, function () { return ({
        focus: function () {
            var _a;
            if (elementRef.current) {
                var prevButton = elementRef.current.getElementsByClassName(styles['calendar-prev-month-btn'])[0];
                (_a = prevButton) === null || _a === void 0 ? void 0 : _a.focus();
            }
        }
    }); });
    var _e = initialStartDate.split('T'), _f = _e[0], initialStartDateString = _f === void 0 ? '' : _f, _g = _e[1], initialStartTimeString = _g === void 0 ? '' : _g;
    var _h = initialEndDate.split('T'), _j = _h[0], initialEndDateString = _j === void 0 ? '' : _j, _k = _h[1], initialEndTimeString = _k === void 0 ? '' : _k;
    var _l = useState(initialStartDateString), startDateString = _l[0], setStartDateString = _l[1];
    var _m = useState(initialStartTimeString), startTimeString = _m[0], setStartTimeString = _m[1];
    var _o = useState(initialEndDateString), endDateString = _o[0], setEndDateString = _o[1];
    var _p = useState(initialEndTimeString), endTimeString = _p[0], setEndTimeString = _p[1];
    var selectedStartDate = parseDate(startDateString, true);
    var selectedEndDate = parseDate(endDateString, true);
    var _q = useState(function () {
        if (startDateString) {
            var startDate = parseDate(startDateString);
            if (isSingleGrid) {
                return startOfMonth(startDate);
            }
            return startOfMonth(addMonths(startDate, 1));
        }
        if (endDateString) {
            return startOfMonth(parseDate(endDateString));
        }
        return startOfMonth(Date.now());
    }), currentMonth = _q[0], setCurrentMonth = _q[1];
    var _r = useState(function () {
        if (selectedStartDate) {
            if (isSameMonth(selectedStartDate, currentMonth)) {
                return selectedStartDate;
            }
            if (!isSingleGrid && isSameMonth(selectedStartDate, addMonths(currentMonth, -1))) {
                return selectedStartDate;
            }
        }
        return selectFocusedDate(selectedStartDate, currentMonth, isDateEnabled);
    }), focusedDate = _r[0], setFocusedDate = _r[1];
    useEffect(function () {
        var startDate = formatISOStringWithoutTimezone(startDateString, startTimeString);
        var endDate = formatISOStringWithoutTimezone(endDateString, endTimeString);
        if (startDate !== initialStartDate || endDate !== initialEndDate) {
            onSelectDateRange({
                startDate: startDate,
                endDate: endDate,
                type: 'absolute'
            });
        }
    }, [
        startDateString,
        startTimeString,
        endDateString,
        endTimeString,
        onSelectDateRange,
        initialStartDate,
        initialEndDate,
    ]);
    var onSelectDateHandler = useCallback(function (selectedDate) {
        if (!startDateString && !endDateString) {
            var startDate = startOfDay(selectedDate);
            setStartDateString(formatDate(startDate));
            setStartTimeString(formatTime(startDate));
            return;
        }
        if (startDateString && endDateString) {
            var startDate = startOfDay(selectedDate);
            setStartDateString(formatDate(startDate));
            setStartTimeString(formatTime(startDate));
            setEndDateString('');
            setEndTimeString('');
            return;
        }
        if (startDateString && !endDateString) {
            var parsedStartDate = parseDate(startDateString);
            if (isBefore(selectedDate, parsedStartDate)) {
                var startDate = startOfDay(selectedDate);
                var endDate = endOfDay(parsedStartDate);
                setStartDateString(formatDate(startDate));
                setStartTimeString(formatTime(startDate));
                setEndDateString(formatDate(endDate));
                setEndTimeString(formatTime(endDate));
            }
            else {
                var endDate = endOfDay(selectedDate);
                setEndDateString(formatDate(endDate));
                setEndTimeString(formatTime(endDate));
            }
            return;
        }
        if (!startDateString && endDateString) {
            var existingEndDate = parseDate(endDateString);
            if (isAfter(selectedDate, existingEndDate)) {
                var startDate = startOfDay(existingEndDate);
                var endDate = endOfDay(selectedDate);
                setStartDateString(formatDate(startDate));
                setStartTimeString(formatTime(startDate));
                setEndDateString(formatDate(endDate));
                setEndTimeString(formatTime(endDate));
            }
            else {
                var startDate = startOfDay(selectedDate);
                setStartDateString(formatDate(startDate));
                setStartTimeString(formatTime(startDate));
            }
            return;
        }
    }, [endDateString, startDateString]);
    var onHeaderChangeMonthHandler = function (isPrevious) {
        var newCurrentMonth = addMonths(currentMonth, isPrevious ? -1 : 1);
        setCurrentMonth(newCurrentMonth);
        var newBaseDateMonth = isSingleGrid ? newCurrentMonth : addMonths(newCurrentMonth, -1);
        var newBaseDate = getBaseDate(newBaseDateMonth, 1, isDateEnabled);
        setFocusedDate(newBaseDate);
    };
    var onChangeStartDate = function (e) {
        var isoDateString = displayToIso(e.detail.value);
        setStartDateString(isoDateString);
        if (isoDateString.length >= 8) {
            var newCurrentMonth = startOfMonth(parseDate(isoDateString));
            setCurrentMonth(isSingleGrid ? newCurrentMonth : addMonths(newCurrentMonth, 1));
        }
    };
    var onChangeEndDate = function (e) {
        var isoDateString = displayToIso(e.detail.value);
        setEndDateString(isoDateString);
    };
    var constrainttextId = useUniqueId('awsui-area-date-range-picker');
    constrainttextId = i18nStrings.dateTimeConstraintText ? constrainttextId : '';
    return (React.createElement(InternalSpaceBetween, { size: "m" },
        React.createElement("div", { className: clsx(styles.calendar, (_b = {},
                _b[styles['one-grid']] = isSingleGrid,
                _b)), role: "application", ref: elementRef },
            React.createElement(CalendarHeader, { baseDate: currentMonth, locale: locale, onChangeMonth: onHeaderChangeMonthHandler, previousMonthLabel: i18nStrings.previousMonthAriaLabel, nextMonthLabel: i18nStrings.nextMonthAriaLabel, calendarHasFocus: true, isSingleGrid: isSingleGrid }),
            React.createElement(Grids, { isSingleGrid: isSingleGrid, locale: locale, baseDate: currentMonth, focusedDate: focusedDate, onFocusedDateChange: setFocusedDate, isDateEnabled: isDateEnabled, onSelectDate: onSelectDateHandler, onChangeMonth: setCurrentMonth, startOfWeek: startOfWeek, todayAriaLabel: i18nStrings.todayAriaLabel, selectedStartDate: selectedStartDate, selectedEndDate: selectedEndDate, handleFocusMove: moveFocusHandler })),
        React.createElement(InternalSpaceBetween, { direction: "vertical", size: "xxs" },
            React.createElement(InternalSpaceBetween, { size: "xs", direction: isSingleGrid ? 'vertical' : 'horizontal' },
                React.createElement("div", { className: styles['date-and-time-wrapper'] },
                    React.createElement("div", { className: styles['date-and-time-wrapper__date'] },
                        React.createElement(InternalFormField, { label: i18nStrings.startDateLabel, stretch: true },
                            React.createElement(DateInput, { value: isoToDisplay(startDateString), autoComplete: false, disableBrowserAutocorrect: true, disableAutocompleteOnBlur: false, className: styles['start-date-input'], onChange: onChangeStartDate, placeholder: "YYYY/MM/DD", ariaDescribedby: constrainttextId }))),
                    !dateOnly && (React.createElement("div", { className: styles['date-and-time-wrapper__time'] },
                        React.createElement(InternalFormField, { label: i18nStrings.startTimeLabel, stretch: true },
                            React.createElement(InternalTimeInput, { value: startTimeString, onChange: function (e) { return setStartTimeString(e.detail.value); }, format: timeInputFormat, placeholder: timeInputFormat, className: styles['start-time-input'], ariaDescribedby: constrainttextId }))))),
                React.createElement("div", { className: styles['date-and-time-wrapper'] },
                    React.createElement("div", { className: styles['date-and-time-wrapper__date'] },
                        React.createElement(InternalFormField, { label: i18nStrings.endDateLabel, stretch: true },
                            React.createElement(DateInput, { value: isoToDisplay(endDateString), autoComplete: false, disableBrowserAutocorrect: true, disableAutocompleteOnBlur: false, className: styles['end-date-input'], onChange: onChangeEndDate, placeholder: "YYYY/MM/DD", ariaDescribedby: constrainttextId }))),
                    !dateOnly && (React.createElement("div", { className: styles['date-and-time-wrapper__time'] },
                        React.createElement(InternalFormField, { label: i18nStrings.endTimeLabel, stretch: true },
                            React.createElement(InternalTimeInput, { value: endTimeString, onChange: function (e) { return setEndTimeString(e.detail.value); }, format: timeInputFormat, placeholder: timeInputFormat, className: styles['end-time-input'], ariaDescribedby: constrainttextId })))))),
            i18nStrings.dateTimeConstraintText && (React.createElement("div", { className: styles['date-and-time-constrainttext'], id: constrainttextId }, i18nStrings.dateTimeConstraintText)))));
}
