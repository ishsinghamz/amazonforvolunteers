import { __assign } from "tslib";
import React, { useCallback, useLayoutEffect, useRef, useState } from 'react';
import clsx from 'clsx';
import { getContainingBlock, nodeContains } from '../internal/utils/dom';
import { useContainerQuery } from '../internal/hooks/container-queries';
import { calculatePosition } from './utils/positions';
import styles from './styles.css.js';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import mergeRefs from 'react-merge-refs';
var INITIAL_STYLES = { position: 'absolute', top: -9999, left: -9999 };
export default function PopoverContainer(_a) {
    var position = _a.position, trackRef = _a.trackRef, trackKey = _a.trackKey, arrow = _a.arrow, children = _a.children, zIndex = _a.zIndex, renderWithPortal = _a.renderWithPortal;
    var _b = useContainerQuery(function (rect, prev) {
        var roundedRect = { width: Math.round(rect.width), height: Math.round(rect.height) };
        return (prev === null || prev === void 0 ? void 0 : prev.width) === roundedRect.width && (prev === null || prev === void 0 ? void 0 : prev.height) === roundedRect.height ? prev : rect;
    }), popoverRect = _b[0], ref = _b[1];
    var bodyRef = useRef(null);
    var arrowRef = useRef(null);
    var _c = useState(INITIAL_STYLES), inlineStyle = _c[0], setInlineStyle = _c[1];
    var _d = useState(null), internalPosition = _d[0], setInternalPosition = _d[1];
    var isRefresh = useVisualRefresh(ref);
    var positionHandlerRef = useRef(function () { });
    var updatePositionHandler = useCallback(function () {
        if (!trackRef.current || !ref.current || !bodyRef.current || !arrowRef.current) {
            return;
        }
        var body = bodyRef.current;
        var arrow = arrowRef.current;
        var document = ref.current.ownerDocument;
        var track = trackRef.current;
        if (body.offsetWidth === 0 || body.offsetHeight === 0 || !nodeContains(document.body, track)) {
            return;
        }
        var prevTop = body.style.top;
        var prevLeft = body.style.left;
        body.style.top = '0';
        body.style.left = '0';
        var viewportRect = getViewportRect(document.defaultView);
        var trackRect = track.getBoundingClientRect();
        var arrowRect = {
            width: parseFloat(getComputedStyle(arrow).width),
            height: parseFloat(getComputedStyle(arrow).height)
        };
        var containingBlock = getContainingBlock(body);
        var containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;
        var bodyRect = body.getBoundingClientRect();
        var bodyRectCeil = {
            top: bodyRect.top,
            left: bodyRect.left,
            width: Math.ceil(bodyRect.width),
            height: Math.ceil(bodyRect.height)
        };
        var _a = calculatePosition(position, trackRect, arrowRect, bodyRectCeil, containingBlock ? containingBlockRect : getDocumentRect(document), viewportRect, renderWithPortal), newInternalPosition = _a.internalPosition, boundingOffset = _a.boundingOffset;
        var popoverOffset = toRelativePosition(boundingOffset, containingBlockRect);
        var trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));
        body.style.top = prevTop;
        body.style.left = prevLeft;
        setInternalPosition(newInternalPosition);
        setInlineStyle({ top: popoverOffset.top, left: popoverOffset.left });
        positionHandlerRef.current = function () {
            var newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);
            setInlineStyle({
                top: newTrackOffset.top + trackRelativeOffset.top,
                left: newTrackOffset.left + trackRelativeOffset.left
            });
        };
    }, [position, trackRef, ref, renderWithPortal]);
    useLayoutEffect(function () {
        updatePositionHandler();
    }, [updatePositionHandler, trackKey, popoverRect]);
    useLayoutEffect(function () {
        var updatePosition = function () { return requestAnimationFrame(function () { return updatePositionHandler(); }); };
        var refreshPosition = function () { return requestAnimationFrame(function () { return positionHandlerRef.current(); }); };
        window.addEventListener('click', updatePosition);
        window.addEventListener('resize', updatePosition);
        window.addEventListener('scroll', refreshPosition, true);
        return function () {
            window.removeEventListener('click', updatePosition);
            window.removeEventListener('resize', updatePosition);
            window.removeEventListener('scroll', refreshPosition, true);
        };
    }, [updatePositionHandler]);
    return (React.createElement("div", { ref: mergeRefs([bodyRef, ref]), style: __assign(__assign({}, inlineStyle), { zIndex: zIndex }), className: clsx(styles.container, isRefresh && styles.refresh) },
        React.createElement("div", { ref: arrowRef, className: clsx(styles["container-arrow"], styles["container-arrow-position-" + internalPosition]), "aria-hidden": true }, arrow(internalPosition)),
        children));
}
function toRelativePosition(element, parent) {
    return {
        top: element.top - parent.top,
        left: element.left - parent.left
    };
}
function getViewportRect(window) {
    return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight
    };
}
function getDocumentRect(document) {
    var _a = document.documentElement.getBoundingClientRect(), top = _a.top, left = _a.left;
    return {
        top: top,
        left: left,
        width: document.documentElement.scrollWidth,
        height: document.documentElement.scrollHeight
    };
}
