import React, { useCallback, useMemo, useRef, useState } from 'react';
import clsx from 'clsx';
import { pie } from 'd3-shape';
import { KeyCode } from '../internal/keycode';
import { nodeContains } from '../internal/utils/dom';
import { useUniqueId } from '../internal/hooks/use-unique-id';
import ChartPopover from '../internal/components/chart-popover';
import SeriesDetails from '../internal/components/chart-series-details';
import SeriesMarker from '../internal/components/chart-series-marker';
import ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';
import InternalBox from '../box/internal';
import Labels from './labels';
import styles from './styles.css.js';
import { defaultDetails, dimensionsBySize, refreshDimensionsBySize } from './utils';
import Segments from './segments';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import ChartPlot from '../internal/components/chart-plot';
export default (function (_a) {
    var _b;
    var _c;
    var _d = _a.variant, variant = _d === void 0 ? 'pie' : _d, _e = _a.size, size = _e === void 0 ? 'medium' : _e, _f = _a.i18nStrings, i18nStrings = _f === void 0 ? {} : _f, ariaLabel = _a.ariaLabel, ariaLabelledby = _a.ariaLabelledby, data = _a.data, visibleData = _a.visibleData, ariaDescription = _a.ariaDescription, innerMetricValue = _a.innerMetricValue, innerMetricDescription = _a.innerMetricDescription, _g = _a.hideTitles, hideTitles = _g === void 0 ? false : _g, _h = _a.hideDescriptions, hideDescriptions = _h === void 0 ? false : _h, detailPopoverContent = _a.detailPopoverContent, detailPopoverSize = _a.detailPopoverSize, width = _a.width, additionalFilters = _a.additionalFilters, hideFilter = _a.hideFilter, hideLegend = _a.hideLegend, _j = _a.statusType, statusType = _j === void 0 ? 'finished' : _j, empty = _a.empty, noMatch = _a.noMatch, errorText = _a.errorText, recoveryText = _a.recoveryText, loadingText = _a.loadingText, onRecoveryClick = _a.onRecoveryClick, segmentDescription = _a.segmentDescription, highlightedSegment = _a.highlightedSegment, onHighlightChange = _a.onHighlightChange, legendSegment = _a.legendSegment, pinnedSegment = _a.pinnedSegment, setPinnedSegment = _a.setPinnedSegment;
    var plotRef = useRef(null);
    var containerRef = useRef(null);
    var focusedSegmentRef = useRef(null);
    var popoverTrackRef = useRef(null);
    var isRefresh = useVisualRefresh(containerRef);
    var dimensions = isRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];
    var radius = dimensions.outerRadius;
    var hasLabels = !(hideTitles && hideDescriptions);
    var height = 2 * (radius + dimensions.padding + (hasLabels ? dimensions.paddingLabels : 0));
    var hasInnerContent = variant === 'donut' && (innerMetricValue || (innerMetricDescription && size !== 'small'));
    var innerMetricId = useUniqueId('awsui-pie-chart__inner');
    var _k = useState(false), isTooltipOpen = _k[0], setTooltipOpen = _k[1];
    var _l = useState(), tooltipData = _l[0], setTooltipData = _l[1];
    var _m = useMemo(function () {
        var dataSum = visibleData.reduce(function (sum, d) { return sum + d.datum.value; }, 0);
        var pieFactory = pie()
            .value(function (d) { return (d.datum.value < dataSum / 100 ? dataSum / 100 : d.datum.value); })
            .sort(null);
        var pieData = pieFactory(visibleData.filter(function (d) { return d.datum.value > 0; }));
        return { pieData: pieData, dataSum: dataSum };
    }, [visibleData]), pieData = _m.pieData, dataSum = _m.dataSum;
    var highlightedSegmentIndex = useMemo(function () {
        for (var index = 0; index < pieData.length; index++) {
            if (pieData[index].data.datum === highlightedSegment) {
                return index;
            }
        }
        return null;
    }, [pieData, highlightedSegment]);
    var detailFunction = detailPopoverContent || defaultDetails(i18nStrings);
    var details = tooltipData ? detailFunction(tooltipData.datum, dataSum) : [];
    var tooltipContent = tooltipData && React.createElement(SeriesDetails, { details: details });
    var _o = getChartStatus({ externalData: data, visibleData: pieData, statusType: statusType }), isEmpty = _o.isEmpty, showChart = _o.showChart;
    var isNoMatch = isEmpty && visibleData.length !== data.length;
    var reserveLegendSpace = !showChart && !hideLegend;
    var reserveFilterSpace = statusType !== 'finished' && !isNoMatch && (!hideFilter || additionalFilters);
    var popoverDismissedRecently = useRef(false);
    var highlightSegment = useCallback(function (internalDatum) {
        var segment = internalDatum.datum;
        if (segment !== highlightedSegment) {
            onHighlightChange(segment);
        }
        if (popoverTrackRef.current) {
            setTooltipData({
                datum: internalDatum.datum,
                series: {
                    color: internalDatum.color,
                    index: internalDatum.index,
                    label: internalDatum.datum.title,
                    markerType: 'rectangle'
                },
                trackRef: popoverTrackRef
            });
            setTooltipOpen(true);
        }
    }, [highlightedSegment, setTooltipOpen, onHighlightChange]);
    var clearHighlightedSegment = useCallback(function () {
        setTooltipOpen(false);
        onHighlightChange(null);
    }, [onHighlightChange, setTooltipOpen]);
    var onClick = useCallback(function (internalDatum) {
        if (pinnedSegment === internalDatum.datum) {
            setPinnedSegment(null);
            clearHighlightedSegment();
        }
        else {
            setPinnedSegment(internalDatum.datum);
            highlightSegment(internalDatum);
        }
    }, [pinnedSegment, clearHighlightedSegment, setPinnedSegment, highlightSegment]);
    var onMouseOver = useCallback(function (internalDatum) {
        if (pinnedSegment !== null) {
            return;
        }
        highlightSegment(internalDatum);
    }, [pinnedSegment, highlightSegment]);
    var onMouseOut = useCallback(function () {
        if (pinnedSegment !== null) {
            return;
        }
        clearHighlightedSegment();
    }, [pinnedSegment, clearHighlightedSegment]);
    var onKeyDown = useCallback(function (event) {
        if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left && event.keyCode !== KeyCode.enter) {
            return;
        }
        event.preventDefault();
        var nextIndex = highlightedSegmentIndex || 0;
        var MAX = pieData.length - 1;
        if (event.keyCode === KeyCode.right) {
            nextIndex++;
            if (nextIndex > MAX) {
                nextIndex = 0;
            }
        }
        else if (event.keyCode === KeyCode.left) {
            nextIndex--;
            if (nextIndex < 0) {
                nextIndex = MAX;
            }
        }
        if (event.keyCode === KeyCode.enter) {
            setPinnedSegment(pieData[nextIndex].data.datum);
        }
        highlightSegment(pieData[nextIndex].data);
    }, [setPinnedSegment, highlightSegment, pieData, highlightedSegmentIndex]);
    var onFocus = useCallback(function (_event, target) {
        if (pinnedSegment !== null || popoverDismissedRecently.current || target === 'mouse') {
            return;
        }
        var segment = highlightedSegment || legendSegment || pieData[0].data.datum;
        var matched = pieData.filter(function (d) { return d.data.datum === segment; });
        highlightSegment(matched[0].data);
    }, [pinnedSegment, pieData, highlightSegment, highlightedSegment, legendSegment]);
    var onBlur = useCallback(function (event) {
        var blurTarget = event.relatedTarget || event.target;
        if (blurTarget === null || !(blurTarget instanceof Element) || !nodeContains(containerRef.current, blurTarget)) {
            clearHighlightedSegment();
            setPinnedSegment(null);
        }
    }, [clearHighlightedSegment, setPinnedSegment]);
    var onPopoverDismiss = function (outsideClick) {
        setTooltipOpen(false);
        setPinnedSegment(null);
        if (!outsideClick) {
            setTimeout(function () {
                popoverDismissedRecently.current = true;
                plotRef.current.focusApplication();
                popoverDismissedRecently.current = false;
            }, 0);
        }
    };
    return (React.createElement("div", { className: clsx(styles.content, styles["content--" + size], (_b = {},
            _b[styles['content--without-labels']] = !hasLabels,
            _b[styles['content--reserve-filter']] = reserveFilterSpace,
            _b[styles['content--reserve-legend']] = reserveLegendSpace,
            _b)) },
        React.createElement(ChartStatusContainer, { isEmpty: isEmpty, isNoMatch: isNoMatch, showChart: showChart, statusType: statusType, empty: empty, noMatch: noMatch, loadingText: loadingText, errorText: errorText, recoveryText: recoveryText, onRecoveryClick: onRecoveryClick }),
        showChart && (React.createElement("div", { className: styles['chart-container'], ref: containerRef },
            React.createElement(ChartPlot, { ref: plotRef, width: width, height: height, transform: "translate(" + width / 2 + " " + height / 2 + ")", isPrecise: true, isClickable: !isTooltipOpen, ariaLabel: ariaLabel, ariaLabelledby: ariaLabelledby, ariaDescription: ariaDescription, ariaDescribedby: hasInnerContent ? innerMetricId : undefined, ariaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.chartAriaRoleDescription, ariaLiveRegion: tooltipContent, activeElementRef: focusedSegmentRef, activeElementKey: highlightedSegmentIndex === null || highlightedSegmentIndex === void 0 ? void 0 : highlightedSegmentIndex.toString(), onFocus: onFocus, onBlur: onBlur, onKeyDown: onKeyDown },
                React.createElement(Segments, { pieData: pieData, size: size, variant: variant, containerRef: containerRef, focusedSegmentRef: focusedSegmentRef, popoverTrackRef: popoverTrackRef, highlightedSegment: highlightedSegment, segmentAriaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.segmentAriaRoleDescription, onClick: onClick, onMouseOver: onMouseOver, onMouseOut: onMouseOut }),
                hasLabels && (React.createElement(Labels, { pieData: pieData, size: size, segmentDescription: segmentDescription, visibleDataSum: dataSum, hideTitles: hideTitles, hideDescriptions: hideDescriptions, highlightedSegment: highlightedSegment, containerRef: containerRef }))),
            hasInnerContent && (React.createElement("div", { className: styles['inner-content'], id: innerMetricId },
                innerMetricValue && (React.createElement(InternalBox, { variant: size === 'small' ? 'h3' : 'h1', tagOverride: "div", color: "inherit", padding: "n" }, innerMetricValue)),
                innerMetricDescription && size !== 'small' && (React.createElement(InternalBox, { variant: "h3", color: "text-body-secondary", tagOverride: "div", padding: "n" }, innerMetricDescription)))),
            isTooltipOpen && tooltipData && (React.createElement(ChartPopover, { title: tooltipData.series && (React.createElement(InternalBox, { className: styles['popover-header'], variant: "strong" },
                    React.createElement(SeriesMarker, { color: tooltipData.series.color, type: tooltipData.series.markerType }),
                    ' ',
                    tooltipData.series.label)), trackRef: tooltipData.trackRef, trackKey: tooltipData.series.index, dismissButton: pinnedSegment !== null, dismissAriaLabel: i18nStrings.detailPopoverDismissAriaLabel, onDismiss: onPopoverDismiss, container: ((_c = plotRef.current) === null || _c === void 0 ? void 0 : _c.svg) || null, size: detailPopoverSize }, tooltipContent))))));
});
