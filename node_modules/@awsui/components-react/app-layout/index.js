import { __assign, __rest } from "tslib";
import clsx from 'clsx';
import React, { useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';
import { getBaseProps } from '../internal/base-component';
import { useControllable } from '../internal/hooks/use-controllable';
import { useMobile } from '../internal/hooks/use-mobile';
import { fireNonCancelableEvent } from '../internal/events';
import { applyDefaults } from './defaults';
import { Notifications } from './notifications';
import { MobileToolbar } from './mobile-toolbar';
import { SplitPanelWrapper } from './split-panel-wrapper';
import { useFocusControl } from './utils/use-focus-control';
import useWindowWidth from './utils/use-window-width';
import useContentHeight from './utils/use-content-height';
import styles from './styles.css.js';
import testutilStyles from './test-utils/styles.css.js';
import { findUpUntil } from '../internal/utils/dom';
import { AppLayoutDomContext } from '../internal/context/app-layout-context';
import { useContainerQuery } from '../internal/hooks/container-queries';
import { useStableEventHandler } from '../internal/hooks/use-stable-event-handler';
import { applyDisplayName } from '../internal/utils/apply-display-name';
import { getSplitPanelDefaultSize, MAIN_PANEL_MIN_HEIGHT } from '../split-panel/utils/size-utils';
import useBaseComponent from '../internal/hooks/use-base-component';
import { useDensityMode, useVisualRefresh } from '../internal/hooks/use-visual-mode';
import ContentWrapper from './content-wrapper';
import { DarkHeader } from './dark-header';
import { isMotionDisabled } from '../internal/motion';
import { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';
import { NavigationPanel } from './navigation-panel';
import { ToolsAndSplitPanel } from './tools-and-split-panel';
import { usePreviousFrameValue } from '../internal/hooks/use-previous-frame';
import useAppLayoutOffsets from './utils/use-content-width';
import { isDevelopment } from '../internal/is-development';
import { warnOnce } from '../internal/logging';
import RefreshedAppLayout from './visual-refresh';
var AppLayout = React.forwardRef(function (_a, ref) {
    var _b = _a.contentType, contentType = _b === void 0 ? 'default' : _b, _c = _a.headerSelector, headerSelector = _c === void 0 ? '#b #h' : _c, _d = _a.footerSelector, footerSelector = _d === void 0 ? '#b #f' : _d, rest = __rest(_a, ["contentType", "headerSelector", "footerSelector"]);
    var __internalRootRef = useBaseComponent('AppLayout').__internalRootRef;
    var isRefresh = useVisualRefresh(__internalRootRef);
    var props = __assign({ contentType: contentType, headerSelector: headerSelector, footerSelector: footerSelector }, rest);
    if (isRefresh) {
        return React.createElement(RefreshedAppLayout, __assign({ __internalRootRef: __internalRootRef }, props, { ref: ref }));
    }
    else {
        return React.createElement(OldAppLayout, __assign({ __internalRootRef: __internalRootRef }, props, { ref: ref }));
    }
});
var OldAppLayout = React.forwardRef(function (_a, ref) {
    var _b, _c;
    var _d;
    var navigation = _a.navigation, _e = _a.navigationWidth, navigationWidth = _e === void 0 ? 280 : _e, navigationHide = _a.navigationHide, controlledNavigationOpen = _a.navigationOpen, tools = _a.tools, _f = _a.toolsWidth, toolsWidth = _f === void 0 ? 290 : _f, toolsHide = _a.toolsHide, controlledToolsOpen = _a.toolsOpen, breadcrumbs = _a.breadcrumbs, notifications = _a.notifications, stickyNotifications = _a.stickyNotifications, contentHeader = _a.contentHeader, disableContentHeaderOverlap = _a.disableContentHeaderOverlap, content = _a.content, _g = _a.contentType, contentType = _g === void 0 ? 'default' : _g, disableContentPaddings = _a.disableContentPaddings, disableBodyScroll = _a.disableBodyScroll, maxContentWidth = _a.maxContentWidth, minContentWidth = _a.minContentWidth, _h = _a.headerSelector, headerSelector = _h === void 0 ? '#b #h' : _h, _j = _a.footerSelector, footerSelector = _j === void 0 ? '#b #f' : _j, ariaLabels = _a.ariaLabels, splitPanel = _a.splitPanel, controlledSplitPanelSize = _a.splitPanelSize, controlledSplitPanelOpen = _a.splitPanelOpen, controlledSplitPanelPreferences = _a.splitPanelPreferences, onSplitPanelPreferencesChange = _a.onSplitPanelPreferencesChange, onSplitPanelResize = _a.onSplitPanelResize, onSplitPanelToggle = _a.onSplitPanelToggle, onNavigationChange = _a.onNavigationChange, onToolsChange = _a.onToolsChange, __internalRootRef = _a.__internalRootRef, rest = __rest(_a, ["navigation", "navigationWidth", "navigationHide", "navigationOpen", "tools", "toolsWidth", "toolsHide", "toolsOpen", "breadcrumbs", "notifications", "stickyNotifications", "contentHeader", "disableContentHeaderOverlap", "content", "contentType", "disableContentPaddings", "disableBodyScroll", "maxContentWidth", "minContentWidth", "headerSelector", "footerSelector", "ariaLabels", "splitPanel", "splitPanelSize", "splitPanelOpen", "splitPanelPreferences", "onSplitPanelPreferencesChange", "onSplitPanelResize", "onSplitPanelToggle", "onNavigationChange", "onToolsChange", "__internalRootRef"]);
    if (isDevelopment) {
        if (controlledToolsOpen && toolsHide) {
            warnOnce('AppLayout', "You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.");
        }
    }
    if (__internalRootRef === null) {
        throw Error('__internalRootRef has to be passed.');
    }
    var baseProps = getBaseProps(rest);
    var isMobile = useMobile();
    var isRefresh = useVisualRefresh(__internalRootRef);
    var isMotionEnabled = __internalRootRef.current ? !isMotionDisabled(__internalRootRef.current) : false;
    var defaults = applyDefaults(contentType, { maxContentWidth: maxContentWidth, minContentWidth: minContentWidth }, isRefresh);
    var darkStickyHeaderContentType = ['cards', 'table'].indexOf(contentType) > -1;
    var darkHeaderContentType = darkStickyHeaderContentType || contentType === 'wizard';
    var _k = useControllable(controlledNavigationOpen, onNavigationChange, isMobile ? false : defaults.navigationOpen, { componentName: 'AppLayout', controlledProp: 'navigationOpen', changeHandler: 'onNavigationChange' }), _l = _k[0], navigationOpen = _l === void 0 ? false : _l, setNavigationOpen = _k[1];
    var _m = useState(navigationOpen ? 'entered' : 'exited'), navigationPanelTransitionState = _m[0], setNavigationPanelTransitionState = _m[1];
    var _o = useControllable(controlledToolsOpen, onToolsChange, isMobile ? false : defaults.toolsOpen, { componentName: 'AppLayout', controlledProp: 'toolsOpen', changeHandler: 'onToolsChange' }), _p = _o[0], toolsOpen = _p === void 0 ? false : _p, setToolsOpen = _o[1];
    var _q = useState(toolsOpen ? 'entered' : 'exited'), toolsPanelTransitionState = _q[0], setToolsPanelTransitionState = _q[1];
    var onNavigationToggle = useCallback(function (open) {
        setNavigationOpen(open);
        fireNonCancelableEvent(onNavigationChange, { open: open });
    }, [setNavigationOpen, onNavigationChange]);
    var onToolsToggle = useCallback(function (open) {
        setToolsOpen(open);
        fireNonCancelableEvent(onToolsChange, { open: open });
    }, [setToolsOpen, onToolsChange]);
    var onNavigationClick = function (event) {
        var hasLink = findUpUntil(event.target, function (node) { return node.tagName === 'A' && !!node.href; });
        if (hasLink) {
            onNavigationToggle(false);
        }
    };
    var navigationVisible = !navigationHide && navigationOpen;
    var toolsVisible = !toolsHide && toolsOpen;
    var _r = useContentHeight(headerSelector, footerSelector, disableBodyScroll), contentHeightStyle = _r.contentHeightStyle, headerHeight = _r.headerHeight, footerHeight = _r.footerHeight, panelHeightStyle = _r.panelHeightStyle;
    var _s = useContainerQuery(function (rect) { return rect.height; }), notificationsHeight = _s[0], notificationsRef = _s[1];
    var _t = useContainerQuery(function (rect) { return (splitPanel ? rect.height : 0); }, [splitPanel]), splitPanelHeight = _t[0], splitPanelRef = _t[1];
    var _u = useContainerQuery(function (rect) { return (splitPanel ? rect.height : 0); }, [splitPanel]), splitPanelHeaderHeight = _u[0], splitPanelHeaderRef = _u[1];
    var anyPanelOpen = navigationVisible || toolsVisible;
    var hasRenderedNotifications = notificationsHeight ? notificationsHeight > 0 : false;
    var stickyNotificationsHeight = stickyNotifications ? notificationsHeight : null;
    var _v = useControllable(controlledSplitPanelPreferences, onSplitPanelPreferencesChange, undefined, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelPreferences',
        changeHandler: 'onSplitPanelPreferencesChange'
    }), splitPanelPreferences = _v[0], setSplitPanelPreferences = _v[1];
    var splitPanelPosition = (splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) || 'bottom';
    var densityMode = useDensityMode(__internalRootRef);
    var closedDrawerWidth = isRefresh ? (densityMode === 'compact' ? 72 : 80) : 40;
    var effectiveNavigationWidth = navigationHide
        ? 0
        : navigationOpen
            ? navigationWidth
            : disableContentPaddings && isRefresh
                ? 0
                : closedDrawerWidth;
    var effectiveToolsWidth = toolsHide && (!splitPanel || (splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) !== 'side')
        ? 0
        : toolsOpen
            ? toolsWidth
            : disableContentPaddings && isRefresh
                ? 0
                : closedDrawerWidth;
    var defaultSplitPanelSize = getSplitPanelDefaultSize(splitPanelPosition);
    var _w = useControllable(controlledSplitPanelSize, onSplitPanelResize, defaultSplitPanelSize, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelSize',
        changeHandler: 'onSplitPanelResize'
    }), _x = _w[0], splitPanelSize = _x === void 0 ? defaultSplitPanelSize : _x, setSplitPanelSize = _w[1];
    var _y = useControllable(controlledSplitPanelOpen, onSplitPanelToggle, false, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelOpen',
        changeHandler: 'onSplitPanelToggle'
    }), _z = _y[0], splitPanelOpen = _z === void 0 ? false : _z, setSplitPanelOpen = _y[1];
    var _0 = useState(splitPanelOpen ? 'entered' : 'exited'), splitPanelTransitionState = _0[0], setSplitPanelTransitionState = _0[1];
    var mainContentRef = useRef(null);
    var legacyScrollRootRef = useRef(null);
    var onSplitPanelPreferencesSet = useCallback(function (detail) {
        setSplitPanelPreferences(detail);
        fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);
    }, [setSplitPanelPreferences, onSplitPanelPreferencesChange]);
    var onSplitPanelSizeSet = useCallback(function (detail) {
        setSplitPanelSize(detail.size);
        fireNonCancelableEvent(onSplitPanelResize, detail);
    }, [setSplitPanelSize, onSplitPanelResize]);
    var onToggle = useCallback(function () {
        setSplitPanelOpen(!splitPanelOpen);
        fireNonCancelableEvent(onSplitPanelToggle, { open: !splitPanelOpen });
    }, [setSplitPanelOpen, splitPanelOpen, onSplitPanelToggle]);
    var getSplitPanelMaxWidth = useStableEventHandler(function () {
        if (!mainContentRef.current || !defaults.minContentWidth) {
            return NaN;
        }
        var width = parseInt(getComputedStyle(mainContentRef.current).width);
        var contentPadding = disableContentPaddings ? 80 : 0;
        var spaceAvailable = width - defaults.minContentWidth - contentPadding;
        var spaceTaken = finalSplitPanePosition === 'side' ? splitPanelSize : 0;
        return Math.max(0, spaceTaken + spaceAvailable);
    });
    var getSplitPanelMaxHeight = useStableEventHandler(function () {
        if (typeof document === 'undefined') {
            return 0;
        }
        else if (disableBodyScroll && legacyScrollRootRef.current) {
            return legacyScrollRootRef.current.clientHeight - MAIN_PANEL_MIN_HEIGHT;
        }
        else {
            return document.documentElement.clientHeight - headerHeight - footerHeight - MAIN_PANEL_MIN_HEIGHT;
        }
    });
    var _1 = useState(false), isForcedPosition = _1[0], setIsForcedPosition = _1[1];
    var finalSplitPanePosition = isForcedPosition ? 'bottom' : splitPanelPosition;
    var splitPaneAvailableOnTheSide = Boolean(splitPanel) && finalSplitPanePosition === 'side';
    var splitPanelOpenOnTheSide = splitPaneAvailableOnTheSide && splitPanelOpen;
    var toggleButtonsBarWidth = isRefresh && (!toolsHide || splitPaneAvailableOnTheSide) ? closedDrawerWidth : 0;
    var windowWidth = useWindowWidth();
    var _2 = useAppLayoutOffsets(__internalRootRef.current), leftOffset = _2.left, rightOffset = _2.right;
    var contentWidthWithSplitPanel = windowWidth -
        leftOffset -
        rightOffset -
        effectiveToolsWidth -
        effectiveNavigationWidth -
        (disableContentPaddings ? 0 : toggleButtonsBarWidth);
    useEffect(function () {
        var contentWidth = contentWidthWithSplitPanel - splitPanelSize;
        setIsForcedPosition(isMobile || (defaults.minContentWidth || 0) > contentWidth);
    }, [contentWidthWithSplitPanel, defaults.minContentWidth, isMobile]);
    var navigationClosedWidth = navigationHide || isRefresh || isMobile ? 0 : closedDrawerWidth;
    var toolsClosedWidth = toolsHide || isRefresh || isMobile ? 0 : closedDrawerWidth;
    useEffectOnUpdate(function () {
        if (finalSplitPanePosition === 'bottom') {
            setSplitPanelTransitionState(splitPanelOpen ? 'entered' : 'exited');
        }
    }, [finalSplitPanePosition, splitPanelOpen]);
    var _3 = useState(), splitPanelLastInteraction = _3[0], setSplitPanelLastInteraction = _3[1];
    useEffectOnUpdate(function () { return setSplitPanelLastInteraction(splitPanelOpen ? { type: 'open' } : { type: 'close' }); }, [splitPanelOpen]);
    useEffectOnUpdate(function () { return setSplitPanelLastInteraction({ type: 'position' }); }, [splitPanelPosition]);
    var contentMaxWidthStyle = !isMobile
        ? { maxWidth: defaults.maxContentWidth }
        : isRefresh
            ? { maxWidth: '100%' }
            : undefined;
    var contentWrapperPaddings = !isMobile && isRefresh
        ? {
            closedNav: !navigationHide && !navigationOpen,
            closedTools: !toolsHide && !toolsOpen
        }
        : undefined;
    var _4 = useState(0), splitPanelReportedSize = _4[0], setSplitPanelReportedSize = _4[1];
    var splitPanelContext = {
        topOffset: (isRefresh ? 0 : headerHeight) + (finalSplitPanePosition === 'bottom' ? stickyNotificationsHeight || 0 : 0),
        bottomOffset: footerHeight,
        leftOffset: leftOffset + (isMobile ? 0 : !navigationHide && navigationOpen ? navigationWidth : navigationClosedWidth),
        rightOffset: rightOffset + (isMobile ? 0 : !toolsHide && toolsOpen ? toolsWidth : toolsClosedWidth),
        position: finalSplitPanePosition,
        size: splitPanelSize,
        getMaxWidth: getSplitPanelMaxWidth,
        getMaxHeight: getSplitPanelMaxHeight,
        disableContentPaddings: disableContentPaddings,
        contentWidthStyles: contentMaxWidthStyle,
        contentWrapperPaddings: contentWrapperPaddings,
        isOpen: splitPanelOpen || (splitPanelTransitionState === 'exiting' && isMotionEnabled),
        isMobile: isMobile,
        isRefresh: isRefresh,
        isForcedPosition: isForcedPosition,
        lastInteraction: splitPanelLastInteraction,
        splitPanelRef: splitPanelRef,
        splitPanelHeaderRef: splitPanelHeaderRef,
        onResize: onSplitPanelSizeSet,
        onToggle: onToggle,
        onPreferencesChange: onSplitPanelPreferencesSet,
        reportSize: setSplitPanelReportedSize
    };
    var contentWrapperProps = {
        navigationPadding: navigationHide || !!navigationOpen,
        toolsPadding: (toolsHide && (!splitPanel || finalSplitPanePosition !== 'side')) ||
            toolsVisible ||
            splitPanelOpenOnTheSide,
        isRefresh: isRefresh,
        isMobile: isMobile
    };
    var navigationRefs = useFocusControl(navigationOpen);
    var toolsRefs = useFocusControl(toolsOpen);
    useImperativeHandle(ref, function () { return ({
        openTools: function () { return onToolsToggle(true); },
        closeNavigationIfNecessary: function () {
            if (isMobile) {
                onNavigationToggle(false);
            }
        }
    }); }, [isMobile, onNavigationToggle, onToolsToggle]);
    var showSideButtonsBar = isRefresh && !!splitPanel && finalSplitPanePosition === 'side';
    var splitPanelBottomOffset = (_d = (!splitPanel || finalSplitPanePosition !== 'bottom'
        ? undefined
        : splitPanelOpen
            ? splitPanelHeight
            : splitPanelHeaderHeight)) !== null && _d !== void 0 ? _d : undefined;
    var contentWidthStyles = !isMobile
        ? { minWidth: defaults.minContentWidth, maxWidth: defaults.maxContentWidth }
        : isRefresh
            ? { maxWidth: '100%' }
            : undefined;
    var isToolsDrawerHidden = disableContentPaddings || (!toolsOpen && showSideButtonsBar);
    var toolsDrawerWidth = (function () {
        if (isMobile) {
            return 0;
        }
        if (isRefresh) {
            if (toolsHide && !splitPanelOpenOnTheSide) {
                return 0;
            }
            if (!toolsVisible && !splitPanelOpenOnTheSide) {
                return disableContentPaddings || showSideButtonsBar ? 0 : closedDrawerWidth;
            }
            var toolsPanelWidth = toolsVisible ? toolsWidth : 0;
            var splitPanelWidth = splitPanelOpenOnTheSide ? splitPanelReportedSize : 0;
            var buttonBar = disableContentPaddings && showSideButtonsBar && (!toolsHide || !splitPanelOpen) ? toggleButtonsBarWidth : 0;
            return toolsPanelWidth + splitPanelWidth + buttonBar;
        }
        else {
            var toolsPanelWidth = toolsHide ? 0 : toolsOpen ? toolsWidth : closedDrawerWidth;
            var splitPanelWidth = !splitPanel || finalSplitPanePosition !== 'side'
                ? 0
                : splitPanelOpen
                    ? splitPanelReportedSize
                    : closedDrawerWidth;
            return toolsPanelWidth + splitPanelWidth;
        }
    })();
    var navigationDrawerWidth = (function () {
        if (isMobile) {
            return 0;
        }
        if (disableContentPaddings && isRefresh && !navigationVisible) {
            return 0;
        }
        return effectiveNavigationWidth;
    })();
    var contentHeaderProps = {
        isMobile: isMobile,
        isRefresh: isRefresh,
        navigationWidth: effectiveNavigationWidth,
        toolsWidth: disableContentPaddings
            ? 0
            : toolsDrawerWidth
                ? toolsDrawerWidth
                : isToolsDrawerHidden
                    ? toggleButtonsBarWidth
                    : 0
    };
    var transitionInProgress = isMotionEnabled &&
        [
            navigationPanelTransitionState,
            toolsPanelTransitionState,
            finalSplitPanePosition === 'side' ? splitPanelTransitionState : undefined,
        ].some(function (state) { return state === 'entering' || state === 'exiting'; });
    var previousContentWidth = usePreviousFrameValue(contentWidthWithSplitPanel - (splitPanelOpenOnTheSide ? splitPanelReportedSize : 0));
    var contentScaleX = (function () {
        if (isMobile || !isMotionEnabled || !disableContentPaddings || !previousContentWidth) {
            return undefined;
        }
        var transitionStarted = isMotionEnabled &&
            [
                navigationPanelTransitionState,
                toolsPanelTransitionState,
                finalSplitPanePosition === 'side' ? splitPanelTransitionState : undefined,
            ].some(function (state) { return state === 'enter' || state === 'exit'; });
        if (transitionStarted) {
            var newContentWidth = contentWidthWithSplitPanel - (splitPanelOpenOnTheSide ? splitPanelReportedSize : 0);
            return previousContentWidth / newContentWidth;
        }
    })();
    var navigationPanelTransitioning = isMotionEnabled && ['enter', 'entering', 'exit', 'exiting'].indexOf(navigationPanelTransitionState) !== -1;
    var toolsPanelTransitioning = isMotionEnabled && ['enter', 'entering', 'exit', 'exiting'].indexOf(toolsPanelTransitionState) !== -1;
    var splitPanelTransitioning = isMotionEnabled && ['enter', 'entering', 'exit', 'exiting'].indexOf(splitPanelTransitionState) !== -1;
    return (React.createElement("div", __assign({}, baseProps, { className: clsx(styles.root, testutilStyles.root, baseProps.className, disableBodyScroll && styles['root-no-scroll']), ref: __internalRootRef }),
        React.createElement("div", { className: styles['layout-wrapper'], style: contentHeightStyle },
            isMobile && (!toolsHide || !navigationHide || breadcrumbs) && (React.createElement(MobileToolbar, { anyPanelOpen: anyPanelOpen && !transitionInProgress, toggleRefs: { navigation: navigationRefs.toggle, tools: toolsRefs.toggle }, isRefresh: isRefresh, topOffset: headerHeight, ariaLabels: ariaLabels, navigationHide: navigationHide, toolsHide: toolsHide, onNavigationOpen: function () { return onNavigationToggle(true); }, onToolsOpen: function () { return onToolsToggle(true); }, unfocusable: anyPanelOpen && !transitionInProgress }, breadcrumbs)),
            React.createElement("div", { className: clsx(styles.layout, disableBodyScroll && styles['layout-no-scroll']) },
                !navigationHide && (React.createElement(NavigationPanel, { ariaLabels: ariaLabels, footerHeight: footerHeight, headerHeight: headerHeight, isHidden: disableContentPaddings, isMobile: isMobile, isMotionEnabled: isMotionEnabled, isRefresh: isRefresh, navigation: navigation, navigationDrawerWidth: navigationDrawerWidth, navigationOpen: navigationOpen, navigationPanelTransitionState: navigationPanelTransitionState, onClick: isMobile ? onNavigationClick : undefined, onNavigationToggle: onNavigationToggle, panelHeightStyle: panelHeightStyle, setNavigationPanelTransitionState: setNavigationPanelTransitionState, toggleRefs: navigationRefs, navigationWidth: navigationWidth })),
                React.createElement("main", { ref: legacyScrollRootRef, className: clsx(styles['layout-main'], (_b = {},
                        _b[styles['layout-main-scrollable']] = disableBodyScroll,
                        _b[styles.unfocusable] = isMobile && anyPanelOpen && !transitionInProgress,
                        _b)) },
                    React.createElement("div", { className: clsx(styles['layout-main-inner'], (_c = {},
                            _c[styles['enable-motion']] = isMotionEnabled && transitionInProgress,
                            _c[styles.refresh] = isRefresh,
                            _c)), style: {
                            marginBottom: splitPanelBottomOffset,
                            transform: contentScaleX ? "scaleX(" + contentScaleX + ")" : undefined,
                            transformOrigin: navigationPanelTransitioning
                                ? 'right'
                                : toolsPanelTransitioning || splitPanelTransitioning
                                    ? 'left'
                                    : undefined
                        } },
                        notifications && (React.createElement(DarkHeader, __assign({}, contentHeaderProps, { topOffset: headerHeight, sticky: !isMobile && darkStickyHeaderContentType && stickyNotifications }),
                            React.createElement(Notifications, { testUtilsClassName: clsx(styles.notifications, testutilStyles.notifications), labels: ariaLabels, topOffset: headerHeight, sticky: !isMobile && stickyNotifications, ref: notificationsRef, isRefresh: isRefresh, isMobile: isMobile, navigationPadding: contentWrapperProps.navigationPadding, toolsPadding: contentWrapperProps.toolsPadding, contentWidthStyles: contentWidthStyles }, notifications))),
                        ((!isMobile && breadcrumbs) || contentHeader) && (React.createElement(DarkHeader, __assign({}, contentHeaderProps),
                            React.createElement(ContentWrapper, __assign({}, contentWrapperProps, { contentWidthStyles: contentWidthStyles }),
                                !isMobile && breadcrumbs && (React.createElement("div", { className: clsx(styles.breadcrumbs, testutilStyles.breadcrumbs, styles['breadcrumbs-desktop'], darkStickyHeaderContentType && styles['breadcrumbs-desktop-sticky-header'], isRefresh && styles['breadcrumbs-desktop-refresh'], isRefresh &&
                                        hasRenderedNotifications &&
                                        styles['breadcrumbs-desktop-refresh-with-notifications']) }, breadcrumbs)),
                                contentHeader && (React.createElement("div", { className: clsx(styles['content-header-wrapper'], isRefresh && styles['content-header-wrapper-refresh'], (!isRefresh || !hasRenderedNotifications) &&
                                        (isMobile || (!breadcrumbs && !isRefresh)) &&
                                        styles['content-extra-top-padding'], !hasRenderedNotifications && !breadcrumbs && styles['content-header-wrapper-first-child'], !disableContentHeaderOverlap && styles['content-header-wrapper-overlapped']) }, contentHeader))))),
                        React.createElement(ContentWrapper, __assign({}, contentWrapperProps, { ref: mainContentRef, disablePaddings: disableContentPaddings, className: clsx(!disableContentPaddings && styles['content-wrapper'], !disableContentPaddings &&
                                (isMobile || !breadcrumbs) &&
                                !contentHeader &&
                                (!isRefresh || !darkHeaderContentType) &&
                                styles['content-extra-top-padding'], isRefresh && styles['content-wrapper-refresh'], !hasRenderedNotifications &&
                                !breadcrumbs &&
                                !isMobile &&
                                !contentHeader &&
                                styles['content-wrapper-first-child']) }),
                            React.createElement(AppLayoutDomContext.RootProvider, { value: {
                                    stickyOffsetTop: headerHeight +
                                        (stickyNotificationsHeight !== null
                                            ? isRefresh
                                                ?
                                                    stickyNotificationsHeight - 5
                                                : stickyNotificationsHeight
                                            : 0),
                                    stickyOffsetBottom: footerHeight + (splitPanelBottomOffset || 0)
                                }, className: clsx(styles.content, testutilStyles.content, isRefresh && styles['content-refresh'], !disableContentHeaderOverlap && contentHeader && styles['content-refresh-overlapped']), style: contentWidthStyles }, content))),
                    finalSplitPanePosition === 'bottom' && (React.createElement(SplitPanelWrapper, { context: splitPanelContext }, splitPanel))),
                React.createElement(ToolsAndSplitPanel, { splitPanel: finalSplitPanePosition === 'side' ? splitPanel : undefined, ariaLabels: ariaLabels, closedDrawerWidth: closedDrawerWidth, contentHeightStyle: contentHeightStyle, disableContentPaddings: disableContentPaddings, drawerWidth: toolsDrawerWidth, footerHeight: footerHeight, headerHeight: headerHeight, isHidden: isToolsDrawerHidden, isMobile: isMobile, isMotionEnabled: isMotionEnabled, isRefresh: isRefresh, onToolsToggle: onToolsToggle, panelHeightStyle: panelHeightStyle, setSplitPanelTransitionState: setSplitPanelTransitionState, setToolsPanelTransitionState: setToolsPanelTransitionState, splitPanelContext: splitPanelContext, splitPanelOpen: splitPanelOpenOnTheSide, splitPanelReportedSize: splitPanelReportedSize, splitPanelTransitionState: splitPanelTransitionState, toggleRefs: toolsRefs, tools: tools, toolsHide: Boolean(toolsHide), toolsOpen: toolsOpen, toolsPanelTransitionState: toolsPanelTransitionState, toolsWidth: toolsWidth })))));
});
applyDisplayName(AppLayout, 'AppLayout');
export default AppLayout;
