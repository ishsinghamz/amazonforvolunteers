import React, { useContext } from 'react';
import clsx from 'clsx';
import { InternalButton } from '../../button/internal';
import { AppLayoutContext } from './context';
import { SplitPanelContext } from '../../internal/context/split-panel-context';
import TriggerButton from './trigger-button';
import styles from './styles.css.js';
import splitPanelStyles from '../../split-panel/styles.css.js';
import testutilStyles from '../test-utils/styles.css.js';
import { useFocusControl } from '../utils/use-focus-control';
import { Transition } from '../../internal/components/transition';
import customCssProps from '../../internal/generated/custom-css-properties';
export default function Tools(_a) {
    var children = _a.children;
    var _b = useContext(AppLayoutContext), ariaLabels = _b.ariaLabels, handleSplitPanelClick = _b.handleSplitPanelClick, handleToolsClick = _b.handleToolsClick, hasDefaultToolsWidth = _b.hasDefaultToolsWidth, isNavigationOpen = _b.isNavigationOpen, isMobile = _b.isMobile, isSplitPanelOpen = _b.isSplitPanelOpen, isToolsOpen = _b.isToolsOpen, splitPanel = _b.splitPanel, tools = _b.tools, toolsHide = _b.toolsHide, toolsWidth = _b.toolsWidth, isAnyPanelOpen = _b.isAnyPanelOpen, navigationHide = _b.navigationHide;
    var _c = useContext(SplitPanelContext), splitPanelPosition = _c.position, openButtonAriaLabel = _c.openButtonAriaLabel;
    var hasSplitPanel = getSplitPanelStatus(splitPanel, splitPanelPosition);
    var hasToolsForm = getToolsFormStatus(hasSplitPanel, isMobile, isSplitPanelOpen, isToolsOpen, toolsHide);
    var hasToolsFormPersistence = getToolsFormPersistence(hasSplitPanel, isSplitPanelOpen, isToolsOpen, toolsHide);
    var focusRefs = useFocusControl(isToolsOpen);
    if (toolsHide && !hasSplitPanel) {
        return null;
    }
    var isUnfocusable = isMobile && isAnyPanelOpen && isNavigationOpen && !navigationHide;
    return (React.createElement(Transition, { "in": isToolsOpen !== null && isToolsOpen !== void 0 ? isToolsOpen : false }, function (state, transitionEventsRef) {
        var _a, _b;
        var _c, _d, _e;
        return (React.createElement("div", { className: clsx(styles['tools-container'], (_a = {},
                _a[testutilStyles['drawer-closed']] = !isToolsOpen,
                _a[styles.unfocusable] = isUnfocusable,
                _a)), style: (_b = {},
                _b[customCssProps.toolsAnimationStartingOpacity] = "" + (hasSplitPanel && isSplitPanelOpen ? 1 : 0),
                _b[customCssProps.toolsWidth] = hasDefaultToolsWidth ? '' : toolsWidth + "px",
                _b) },
            children,
            !toolsHide && (React.createElement("aside", { "aria-hidden": !isToolsOpen ? true : false, "aria-label": (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tools) !== null && _c !== void 0 ? _c : undefined, className: clsx(styles.tools, state === 'entering' && styles.animating, testutilStyles.tools), ref: state !== 'exiting' ? transitionEventsRef : undefined, "data-is-tools-open": isToolsOpen ? true : false, "data-has-tools-form-persistence": hasToolsFormPersistence ? true : false },
                React.createElement("div", { className: clsx(styles['animated-content']) },
                    React.createElement("div", { className: clsx(styles['hide-tools']) },
                        React.createElement(InternalButton, { ariaLabel: (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.toolsClose) !== null && _d !== void 0 ? _d : undefined, iconName: isMobile ? 'close' : 'angle-right', onClick: function () { return handleToolsClick(false); }, variant: "icon", formAction: "none", className: testutilStyles['tools-close'], ref: focusRefs.close })),
                    tools))),
            !isMobile && (React.createElement("aside", { "aria-hidden": !hasToolsForm ? true : false, "aria-label": (_e = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tools) !== null && _e !== void 0 ? _e : undefined, className: clsx(styles['show-tools'], splitPanelStyles.root, state === 'exiting' && styles.animating), ref: state === 'exiting' ? transitionEventsRef : undefined, "data-has-tools-form": hasToolsForm ? true : false, "data-has-tools-form-persistence": hasToolsFormPersistence ? true : false },
                !toolsHide && (React.createElement(TriggerButton, { ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.toolsToggle, iconName: "status-info", onClick: function () { return handleToolsClick(!isToolsOpen); }, selected: hasSplitPanel && isToolsOpen, className: testutilStyles['tools-toggle'], ref: focusRefs.toggle })),
                hasSplitPanel && (React.createElement(TriggerButton, { ariaLabel: openButtonAriaLabel, iconName: "view-vertical", onClick: function () { return handleSplitPanelClick(); }, selected: hasSplitPanel && isSplitPanelOpen, className: splitPanelStyles['open-button'] }))))));
    }));
}
export function getToolsDefaultState(isMobile, stateFromProps) {
    var isToolsOpen;
    if (isMobile || stateFromProps === undefined) {
        isToolsOpen = false;
    }
    else {
        isToolsOpen = stateFromProps;
    }
    return isToolsOpen;
}
function getSplitPanelStatus(splitPanel, splitPanelPosition) {
    return splitPanel && splitPanelPosition === 'side' ? true : false;
}
function getToolsFormStatus(hasSplitPanel, isMobile, isSplitPanelOpen, isToolsOpen, toolsHide) {
    var hasToolsForm = false;
    if (!isMobile) {
        if (hasSplitPanel && !toolsHide) {
            hasToolsForm = true;
        }
        if (hasSplitPanel && !isSplitPanelOpen && toolsHide) {
            hasToolsForm = true;
        }
        if (!hasSplitPanel && !toolsHide && !isToolsOpen) {
            hasToolsForm = true;
        }
    }
    return hasToolsForm;
}
function getToolsFormPersistence(hasSplitPanel, isSplitPanelOpen, isToolsOpen, toolsHide) {
    var hasToolsFormPersistence = false;
    if (hasSplitPanel && !toolsHide && (isSplitPanelOpen || isToolsOpen)) {
        hasToolsFormPersistence = true;
    }
    return hasToolsFormPersistence;
}
