import { __assign, __rest } from "tslib";
import React, { createContext, createRef, useCallback, useEffect, useLayoutEffect, useImperativeHandle, useRef, useState, } from 'react';
import { fireNonCancelableEvent } from '../../internal/events';
import { getSplitPanelDefaultSize, getSplitPanelPosition } from './split-panel';
import { useControllable } from '../../internal/hooks/use-controllable';
import { useMobile } from '../../internal/hooks/use-mobile';
import { useContainerQuery } from '../../internal/hooks/container-queries';
import styles from './styles.css.js';
import { isDevelopment } from '../../internal/is-development';
import { warnOnce } from '../../internal/logging';
import { applyDefaults } from '../defaults';
var defaults = {
    breadcrumbs: null,
    content: null,
    contentHeader: null,
    contentType: 'default',
    disableBodyScroll: false,
    disableContentHeaderOverlap: false,
    disableContentPaddings: false,
    footerSelector: '#b #f',
    handleNavigationClick: function (value) { return value; },
    handleSplitPanelClick: function () { },
    handleSplitPanelPreferencesChange: function () { },
    handleSplitPanelResize: function () { },
    handleToolsClick: function (value) { return value; },
    hasDefaultToolsWidth: true,
    hasNotificationsContent: false,
    headerSelector: '#b #h',
    isAnyPanelOpen: false,
    isMobile: false,
    isNavigationOpen: false,
    isSplitPanelForcedPosition: false,
    isSplitPanelOpen: false,
    isOverlapDisabled: false,
    isToolsOpen: false,
    layoutElement: createRef(),
    layoutWidth: 0,
    mainElement: createRef(),
    mainOffsetLeft: 0,
    maxContentWidth: 0,
    minContentWidth: 280,
    navigation: null,
    navigationHide: false,
    navigationOpen: false,
    notifications: null,
    notificationsElement: createRef(),
    notificationsHeight: 0,
    onNavigationChange: function () { },
    onSplitPanelResize: function () { },
    onSplitPanelToggle: function () { },
    onSplitPanelPreferencesChange: function () { },
    setIsNavigationOpen: function (value) { return value; },
    setIsToolsOpen: function (value) { return value; },
    setSplitPanelReportedSize: function (value) { return void value; },
    splitPanelMaxWidth: 280,
    splitPanelMinWidth: 280,
    splitPanelOpen: false,
    splitPanelPosition: 'bottom',
    splitPanelPreferences: { position: 'bottom' },
    splitPanelReportedSize: 0,
    splitPanelSize: 0,
    stickyNotifications: false,
    tools: null
};
export var AppLayoutContext = createContext(__assign({}, defaults));
export var AppLayoutProvider = React.forwardRef(function (_a, forwardRef) {
    var _b, _c, _d;
    var toolsHide = _a.toolsHide, controlledToolsOpen = _a.toolsOpen, navigationHide = _a.navigationHide, controlledNavigationOpen = _a.navigationOpen, _e = _a.contentType, contentType = _e === void 0 ? 'default' : _e, children = _a.children, props = __rest(_a, ["toolsHide", "toolsOpen", "navigationHide", "navigationOpen", "contentType", "children"]);
    var isMobile = useMobile();
    if (isDevelopment) {
        if (controlledToolsOpen && toolsHide) {
            warnOnce('AppLayout', "You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.");
        }
    }
    var isOverlapDisabled = !props.contentHeader || props.disableContentHeaderOverlap === true;
    var maxContentWidth = (_b = props.maxContentWidth) !== null && _b !== void 0 ? _b : 0;
    var minContentWidth = (_c = props.minContentWidth) !== null && _c !== void 0 ? _c : 280;
    var contentTypeDefaults = applyDefaults(contentType, { maxContentWidth: maxContentWidth, minContentWidth: minContentWidth }, true);
    var _f = useControllable(controlledNavigationOpen, props.onNavigationChange, isMobile ? false : contentTypeDefaults.navigationOpen, { componentName: 'AppLayout', controlledProp: 'navigationOpen', changeHandler: 'onNavigationChange' }), _g = _f[0], isNavigationOpen = _g === void 0 ? false : _g, setIsNavigationOpen = _f[1];
    var handleNavigationClick = useCallback(function handleNavigationChange(isOpen) {
        setIsNavigationOpen(isOpen);
        fireNonCancelableEvent(props.onNavigationChange, { open: isOpen });
    }, [props.onNavigationChange, setIsNavigationOpen]);
    var toolsWidth = (_d = props.toolsWidth) !== null && _d !== void 0 ? _d : 290;
    var hasDefaultToolsWidth = props.toolsWidth === undefined;
    var _h = useControllable(controlledToolsOpen, props.onToolsChange, isMobile ? false : contentTypeDefaults.toolsOpen, { componentName: 'AppLayout', controlledProp: 'toolsOpen', changeHandler: 'onToolsChange' }), _j = _h[0], isToolsOpen = _j === void 0 ? false : _j, setIsToolsOpen = _h[1];
    var handleToolsClick = useCallback(function handleToolsChange(isOpen) {
        setIsToolsOpen(isOpen);
        fireNonCancelableEvent(props.onToolsChange, { open: isOpen });
    }, [props.onToolsChange, setIsToolsOpen]);
    var navigationVisible = !navigationHide && isNavigationOpen;
    var toolsVisible = !toolsHide && isToolsOpen;
    var isAnyPanelOpen = navigationVisible || toolsVisible;
    useEffect(function handleBodyScroll() {
        if (isMobile && (isNavigationOpen || isToolsOpen)) {
            document.body.classList.add(styles['block-body-scroll']);
        }
        else {
            document.body.classList.remove(styles['block-body-scroll']);
        }
        return function cleanup() {
            document.body.classList.remove(styles['block-body-scroll']);
        };
    }, [isMobile, isNavigationOpen, isToolsOpen]);
    useImperativeHandle(forwardRef, function createImperativeHandle() {
        return {
            closeNavigationIfNecessary: function () {
                isMobile && handleNavigationClick(false);
            },
            openTools: function () {
                handleToolsClick(true);
            }
        };
    }, [isMobile, handleNavigationClick, handleToolsClick]);
    var splitPanelMinWidth = 280;
    var _k = useState(splitPanelMinWidth), splitPanelMaxWidth = _k[0], setSplitPanelMaxWidth = _k[1];
    var _l = useControllable(props.splitPanelOpen, props.onSplitPanelToggle, false, { componentName: 'AppLayout', controlledProp: 'splitPanelOpen', changeHandler: 'onSplitPanelToggle' }), isSplitPanelOpen = _l[0], setIsSplitPanelOpen = _l[1];
    var handleSplitPanelClick = useCallback(function handleSplitPanelChange() {
        setIsSplitPanelOpen(!isSplitPanelOpen);
        fireNonCancelableEvent(props.onSplitPanelToggle, { open: !isSplitPanelOpen });
    }, [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]);
    var _m = useControllable(props.splitPanelPreferences, props.onSplitPanelPreferencesChange, undefined, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelPreferences',
        changeHandler: 'onSplitPanelPreferencesChange'
    }), splitPanelPreferences = _m[0], setSplitPanelPreferences = _m[1];
    var _o = useState(false), isSplitPanelForcedPosition = _o[0], setSplitPanelForcedPosition = _o[1];
    var splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);
    useLayoutEffect(function handleSplitPanelForcePosition() {
        setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);
    }, [splitPanelMaxWidth, splitPanelMinWidth]);
    var _p = useState(0), splitPanelReportedSize = _p[0], setSplitPanelReportedSize = _p[1];
    var _q = useControllable(props.splitPanelSize, props.onSplitPanelResize, getSplitPanelDefaultSize(splitPanelPosition), { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }), splitPanelSize = _q[0], setSplitPanelSize = _q[1];
    var handleSplitPanelResize = useCallback(function handleSplitPanelChange(detail) {
        setSplitPanelSize(detail.size);
        fireNonCancelableEvent(props.onSplitPanelResize, detail);
    }, [props.onSplitPanelResize, setSplitPanelSize]);
    var handleSplitPanelPreferencesChange = useCallback(function handleSplitPanelChange(detail) {
        setSplitPanelPreferences(detail);
        fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);
    }, [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]);
    var _r = useContainerQuery(function (rect) { return rect.width; }), layoutContainerQuery = _r[0], layoutElement = _r[1];
    var layoutWidth = layoutContainerQuery !== null && layoutContainerQuery !== void 0 ? layoutContainerQuery : 0;
    var mainElement = useRef(null);
    var _s = useState(0), mainOffsetLeft = _s[0], setMainOffsetLeft = _s[1];
    useLayoutEffect(function handleMainOffsetLeft() {
        var _a, _b;
        setMainOffsetLeft((_b = (_a = mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) === null || _a === void 0 ? void 0 : _a.offsetLeft) !== null && _b !== void 0 ? _b : 0);
    }, [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]);
    useLayoutEffect(function handleSplitPanelMaxWidth() {
        var contentGapRight = 80;
        var toolsFormOffsetWidth = 160;
        var toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;
        setSplitPanelMaxWidth(layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth);
    }, [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]);
    var _t = useContainerQuery(function (rect) { return rect.height; }), notificationsContainerQuery = _t[0], notificationsElement = _t[1];
    var _u = useState(0), notificationsHeight = _u[0], setNotificationsHeight = _u[1];
    var _v = useState(false), hasNotificationsContent = _v[0], setHasNotificationsContent = _v[1];
    useEffect(function handleNotificationsContent() {
        setNotificationsHeight(notificationsContainerQuery !== null && notificationsContainerQuery !== void 0 ? notificationsContainerQuery : 0);
        setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);
    }, [notificationsContainerQuery]);
    return (React.createElement(AppLayoutContext.Provider, { value: __assign(__assign(__assign({}, defaults), props), { contentType: contentType, hasDefaultToolsWidth: hasDefaultToolsWidth, handleNavigationClick: handleNavigationClick, handleSplitPanelClick: handleSplitPanelClick, handleSplitPanelPreferencesChange: handleSplitPanelPreferencesChange, handleSplitPanelResize: handleSplitPanelResize, handleToolsClick: handleToolsClick, hasNotificationsContent: hasNotificationsContent, isAnyPanelOpen: isAnyPanelOpen, isMobile: isMobile, isNavigationOpen: isNavigationOpen !== null && isNavigationOpen !== void 0 ? isNavigationOpen : false, isOverlapDisabled: isOverlapDisabled, isSplitPanelForcedPosition: isSplitPanelForcedPosition, isSplitPanelOpen: isSplitPanelOpen, isToolsOpen: isToolsOpen, layoutElement: layoutElement, layoutWidth: layoutWidth, mainElement: mainElement, mainOffsetLeft: mainOffsetLeft, maxContentWidth: maxContentWidth, minContentWidth: minContentWidth, navigationHide: navigationHide, notificationsElement: notificationsElement, notificationsHeight: notificationsHeight, setSplitPanelReportedSize: setSplitPanelReportedSize, splitPanelMaxWidth: splitPanelMaxWidth, splitPanelMinWidth: splitPanelMinWidth, splitPanelPosition: splitPanelPosition, splitPanelPreferences: splitPanelPreferences, splitPanelReportedSize: splitPanelReportedSize, splitPanelSize: splitPanelSize, toolsHide: toolsHide, toolsOpen: isToolsOpen, toolsWidth: toolsWidth }) }, children));
});
