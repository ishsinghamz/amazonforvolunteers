import { useEffect, useMemo, useRef } from 'react';
import { findClosest, circleIndex, throttle } from './utils';
import { nodeContains } from '../../internal/utils/dom';
import { KeyCode } from '../../internal/keycode';
import { useReaction } from './async-store';
import computeChartProps from './compute-chart-props';
import createSeriesDecorator from './create-series-decorator';
import InteractionsStore from './interactions-store';
import { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';
var MAX_HOVER_MARGIN = 6;
var SVG_HOVER_THROTTLE = 25;
export default function useChartModel(_a) {
    var allSeries = _a.externalSeries, series = _a.visibleSeries, setVisibleSeries = _a.setVisibleSeries, highlightedSeries = _a.highlightedSeries, setHighlightedSeries = _a.setHighlightedSeries, xDomain = _a.xDomain, yDomain = _a.yDomain, xScaleType = _a.xScaleType, yScaleType = _a.yScaleType, height = _a.height, width = _a.width;
    var plotRef = useRef(null);
    var containerRef = useRef(null);
    var verticalMarkerRef = useRef(null);
    var stableSetVisibleSeries = useStableEventHandler(setVisibleSeries);
    var model = useMemo(function () {
        var computed = computeChartProps({
            series: series,
            xDomain: xDomain,
            yDomain: yDomain,
            xScaleType: xScaleType,
            yScaleType: yScaleType,
            height: height,
            width: width
        });
        var interactions = new InteractionsStore(series, computed.plot);
        var getInternalSeries = createSeriesDecorator(allSeries);
        var onSVGMouseMoveThrottled = throttle(function (clientX, clientY) {
            if (interactions.get().isPopoverPinned || !plotRef.current || interactions.plot.xy.length === 0) {
                return;
            }
            var svgRect = plotRef.current.svg.getBoundingClientRect();
            var offsetX = clientX - svgRect.left;
            var offsetY = clientY - svgRect.top;
            var closestX = findClosest(interactions.plot.xy, offsetX, function (xPoints) { return xPoints[0].scaled.x; });
            var closestPoint = findClosest(closestX, offsetY, function (point) { return point.scaled.y1; });
            if (Math.abs(offsetX - closestPoint.scaled.x) < MAX_HOVER_MARGIN &&
                Math.abs(offsetY - closestPoint.scaled.y1) < MAX_HOVER_MARGIN) {
                interactions.highlightPoint(closestPoint);
            }
            else {
                interactions.highlightX(closestX);
            }
        }, SVG_HOVER_THROTTLE);
        var onSVGMouseMove = function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY;
            return onSVGMouseMoveThrottled(clientX, clientY);
        };
        var onSVGMouseOut = function (event) {
            onSVGMouseMoveThrottled.cancel();
            if (interactions.get().isPopoverPinned) {
                return;
            }
            if (!nodeContains(plotRef.current.svg, event.relatedTarget)) {
                interactions.clearHighlight();
            }
        };
        var onSVGMouseDown = function () {
            interactions.togglePopoverPin();
        };
        var moveWithinSeries = function (direction) {
            var point = interactions.get().highlightedPoint;
            if (!point) {
                return;
            }
            var sIndex = point.index.s;
            var xIndex = circleIndex(point.index.x + direction, [0, interactions.plot.xs.length - 1]);
            interactions.highlightPoint(interactions.plot.xs[xIndex][sIndex]);
        };
        var moveBetweenSeries = function (direction) {
            var point = interactions.get().highlightedPoint;
            if (!point) {
                return;
            }
            var xIndex = point.index.x;
            var yIndex = circleIndex(point.index.y + direction, [0, interactions.plot.xy[xIndex].length - 1]);
            interactions.highlightPoint(interactions.plot.xy[xIndex][yIndex]);
        };
        var onSVGKeyDown = function (event) {
            var keyCode = event.keyCode;
            if (keyCode !== KeyCode.up &&
                keyCode !== KeyCode.right &&
                keyCode !== KeyCode.down &&
                keyCode !== KeyCode.left &&
                keyCode !== KeyCode.space &&
                keyCode !== KeyCode.enter) {
                return;
            }
            event.preventDefault();
            if (interactions.get().isPopoverPinned) {
                return;
            }
            if (keyCode === KeyCode.down || keyCode === KeyCode.up) {
                moveBetweenSeries(keyCode === KeyCode.down ? -1 : 1);
            }
            else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {
                moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);
            }
            else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
                interactions.pinPopover();
            }
        };
        var onSVGFocus = function (_event, trigger) {
            if (trigger === 'keyboard') {
                interactions.highlightFirstPoint();
            }
        };
        var onSVGBlur = function () {
            if (!interactions.get().isPopoverPinned) {
                interactions.clearHighlight();
            }
        };
        var onFilterSeries = function (series) {
            stableSetVisibleSeries(series);
        };
        var onLegendHighlight = function (series) {
            interactions.highlightSeries(series);
        };
        var onPopoverDismiss = function (outsideClick) {
            interactions.unpinPopover();
            if (!outsideClick) {
                setTimeout(function () {
                    if (interactions.get().highlightedPoint) {
                        plotRef.current.focusApplication();
                    }
                    else {
                        interactions.clearHighlight();
                        plotRef.current.focusPlot();
                    }
                }, 0);
            }
        };
        var onContainerBlur = function () {
            interactions.clearState();
        };
        return {
            width: width,
            height: height,
            series: series,
            allSeries: allSeries,
            getInternalSeries: getInternalSeries,
            computed: computed,
            interactions: interactions,
            handlers: {
                onSVGMouseMove: onSVGMouseMove,
                onSVGMouseOut: onSVGMouseOut,
                onSVGMouseDown: onSVGMouseDown,
                onSVGKeyDown: onSVGKeyDown,
                onSVGFocus: onSVGFocus,
                onSVGBlur: onSVGBlur,
                onFilterSeries: onFilterSeries,
                onLegendHighlight: onLegendHighlight,
                onPopoverDismiss: onPopoverDismiss,
                onContainerBlur: onContainerBlur
            },
            refs: {
                plot: plotRef,
                container: containerRef,
                verticalMarker: verticalMarkerRef
            }
        };
    }, [allSeries, series, xDomain, yDomain, xScaleType, yScaleType, height, width, stableSetVisibleSeries]);
    useReaction(model.interactions, function (state) { return state.highlightedSeries; }, setHighlightedSeries);
    useEffect(function () {
        if (highlightedSeries !== model.interactions.get().highlightedSeries) {
            model.interactions.highlightSeries(highlightedSeries);
        }
    }, [model, highlightedSeries]);
    return model;
}
