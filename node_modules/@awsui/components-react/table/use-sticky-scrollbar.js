import { ResizeObserver } from '@juggle/resize-observer';
import { useEffect, useState } from 'react';
import styles from './styles.css.js';
import { getOverflowParentDimensions } from '../internal/utils/scrollable-containers';
import { browserScrollbarSize } from '../internal/utils/browser-scrollbar-size';
import { supportsStickyPosition, getContainingBlock } from '../internal/utils/dom';
var updatePosition = function (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) {
    if (!tableEl || !scrollbarEl || !wrapperEl) {
        return;
    }
    var parent = getOverflowParentDimensions(wrapperEl)[0];
    var parentBottom = parent.top + parent.height;
    var _a = tableEl.getBoundingClientRect(), tableTop = _a.top, tableBottom = _a.bottom, tableWidth = _a.width;
    var wrapperWidth = wrapperEl.getBoundingClientRect().width;
    var scrollbarHeight = browserScrollbarSize().height;
    var scrollBarCorrection = scrollbarHeight > 0 ? scrollbarHeight : -15 / 2;
    var tableBottomIsVisible = parentBottom - consideredFooterHeight >= tableBottom + scrollBarCorrection;
    var tableTopIsHidden = tableTop >= parentBottom - consideredFooterHeight - scrollBarCorrection;
    var areaIsScrollable = tableWidth > wrapperWidth;
    if (tableBottomIsVisible || tableTopIsHidden || !areaIsScrollable) {
        scrollbarEl.classList.remove(styles['sticky-scrollbar-visible']);
    }
    else {
        if (!scrollbarEl.classList.contains(styles['sticky-scrollbar-visible'])) {
            requestAnimationFrame(function () {
                scrollbarEl.scrollLeft = wrapperEl.scrollLeft;
            });
        }
        scrollbarEl.classList.add(styles['sticky-scrollbar-visible']);
    }
    if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {
        scrollbarEl.style.height = scrollbarHeight + "px";
        scrollbarContentEl.style.height = scrollbarHeight + "px";
    }
    if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {
        var parent_1 = getOverflowParentDimensions(wrapperEl)[0];
        var wrapperElRect = wrapperEl.getBoundingClientRect();
        var tableElRect = tableEl.getBoundingClientRect();
        scrollbarEl.style.width = wrapperElRect.width + "px";
        scrollbarContentEl.style.width = tableElRect.width + "px";
        scrollbarEl.style.left = hasContainingBlock ? '0px' : wrapperElRect.left + "px";
        scrollbarEl.style.top = hasContainingBlock
            ? '0px'
            : Math.min(parent_1.top + parent_1.height, window.innerHeight - consideredFooterHeight) + "px";
    }
};
export function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight) {
    var _a = useState(false), hasContainingBlock = _a[0], setHasContainingBlock = _a[1];
    var consideredFooterHeight = hasContainingBlock ? 0 : footerHeight;
    useEffect(function () {
        if (supportsStickyPosition()) {
            var scrollHandler_1 = function () {
                updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
            };
            scrollHandler_1();
            window.addEventListener('scroll', scrollHandler_1, true);
            return function () {
                window.removeEventListener('scroll', scrollHandler_1, true);
            };
        }
    }, [scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, scrollbarContentRef, hasContainingBlock]);
    var wrapperEl = wrapperRef.current;
    useEffect(function () {
        if (wrapperEl && supportsStickyPosition()) {
            setHasContainingBlock(!!getContainingBlock(wrapperEl));
        }
    }, [wrapperEl]);
    useEffect(function () {
        if (supportsStickyPosition() && tableRef.current) {
            var observer_1 = new ResizeObserver(function (entries) {
                if (scrollbarContentRef.current) {
                    scrollbarContentRef.current.style.width = entries[0].borderBoxSize[0].inlineSize + "px";
                    updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
                }
            });
            observer_1.observe(tableRef.current);
            return function () {
                observer_1.disconnect();
            };
        }
    }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);
    useEffect(function () {
        if (supportsStickyPosition()) {
            var resizeHandler_1 = function () {
                updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
            };
            window.addEventListener('resize', resizeHandler_1);
            return function () {
                window.removeEventListener('resize', resizeHandler_1);
            };
        }
    }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);
}
