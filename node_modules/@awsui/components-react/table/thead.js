import { __assign } from "tslib";
import clsx from 'clsx';
import React from 'react';
import SelectionControl from './selection-control';
import { focusMarkers } from './use-selection';
import { fireNonCancelableEvent } from '../internal/events';
import { getColumnKey } from './utils';
import { TableHeaderCell } from './header-cell';
import { Resizer } from './resizer';
import { useColumnWidths } from './use-column-widths';
import styles from './styles.css.js';
var Thead = React.forwardRef(function (_a, outerRef) {
    var containerWidth = _a.containerWidth, selectionType = _a.selectionType, selectAllProps = _a.selectAllProps, columnDefinitions = _a.columnDefinitions, sortingColumn = _a.sortingColumn, sortingDisabled = _a.sortingDisabled, sortingDescending = _a.sortingDescending, resizableColumns = _a.resizableColumns, variant = _a.variant, wrapLines = _a.wrapLines, onFocusMove = _a.onFocusMove, onCellFocus = _a.onCellFocus, onCellBlur = _a.onCellBlur, onSortingChange = _a.onSortingChange, onResizeFinish = _a.onResizeFinish, _b = _a.showFocusRing, showFocusRing = _b === void 0 ? null : _b, _c = _a.sticky, sticky = _c === void 0 ? false : _c, _d = _a.hidden, hidden = _d === void 0 ? false : _d, _e = _a.stuck, stuck = _e === void 0 ? false : _e;
    var headerCellClass = clsx(styles.cell, styles['header-cell'], styles["header-cell-variant-" + variant], sticky && styles['header-cell-sticky'], stuck && styles['header-cell-stuck']);
    var _f = useColumnWidths(), columnWidths = _f.columnWidths, totalWidth = _f.totalWidth, updateColumn = _f.updateColumn;
    return (React.createElement("thead", { className: clsx(!hidden && styles['thead-active']) },
        React.createElement("tr", __assign({}, focusMarkers.all, { ref: outerRef }),
            selectionType === 'multi' && (React.createElement(SelectionControl, __assign({ className: clsx(headerCellClass, styles['selection-control']), onFocusDown: function (event) { return onFocusMove(event.target, -1, +1); } }, selectAllProps, (hidden ? { tabIndex: -1 } : {}), { rootTag: "th", scope: "col" }))),
            selectionType === 'single' && (React.createElement("th", { className: clsx(headerCellClass, styles['selection-control']), scope: "col" },
                React.createElement("span", { className: styles.stud, "aria-hidden": true }, "\u00A0"))),
            columnDefinitions.map(function (column, colIndex) {
                var widthOverride;
                if (resizableColumns) {
                    if (columnWidths) {
                        widthOverride = columnWidths[getColumnKey(column, colIndex)];
                    }
                    if (colIndex === columnDefinitions.length - 1 && containerWidth && containerWidth > totalWidth) {
                        widthOverride = 'auto';
                    }
                }
                return (React.createElement(TableHeaderCell, { key: getColumnKey(column, colIndex), className: headerCellClass, style: {
                        width: widthOverride || column.width,
                        minWidth: sticky ? undefined : column.minWidth,
                        maxWidth: resizableColumns || sticky ? undefined : column.maxWidth
                    }, tabIndex: sticky ? -1 : 0, showFocusRing: colIndex === showFocusRing, column: column, activeSortingColumn: sortingColumn, sortingDescending: sortingDescending, sortingDisabled: sortingDisabled, wrapLines: wrapLines, resizer: resizableColumns && (React.createElement(Resizer, { onDragMove: function (newWidth) { return updateColumn(colIndex, newWidth); }, onFinish: function () { return onResizeFinish(columnWidths); } })), onClick: function (detail) { return fireNonCancelableEvent(onSortingChange, detail); }, onFocus: function () { return onCellFocus === null || onCellFocus === void 0 ? void 0 : onCellFocus(colIndex); }, onBlur: onCellBlur }));
            }))));
});
export default Thead;
