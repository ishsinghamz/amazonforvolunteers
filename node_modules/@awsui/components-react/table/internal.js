import { __assign, __rest } from "tslib";
import clsx from 'clsx';
import React, { useImperativeHandle, useRef } from 'react';
import InternalContainer from '../container/internal';
import { getBaseProps } from '../internal/base-component';
import ToolsHeader from './tools-header';
import Thead from './thead';
import InternalStatusIndicator from '../status-indicator/internal';
import { useContainerQuery } from '../internal/hooks/container-queries';
import { supportsStickyPosition } from '../internal/utils/dom';
import SelectionControl from './selection-control';
import { checkSortingState, getColumnKey, getItemKey, toContainerVariant } from './utils';
import { useRowEvents } from './use-row-events';
import { focusMarkers, useFocusMove, useSelection } from './use-selection';
import { fireNonCancelableEvent } from '../internal/events';
import { isDevelopment } from '../internal/is-development';
import { checkColumnWidths, ColumnWidthsProvider, DEFAULT_WIDTH } from './use-column-widths';
import { useScrollSync } from '../internal/hooks/use-scroll-sync';
import { ResizeTracker } from './resizer';
import styles from './styles.css.js';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import StickyHeader from './sticky-header';
import StickyScrollbar from './sticky-scrollbar';
var InternalTable = React.forwardRef(function (_a, ref) {
    var _b;
    var header = _a.header, footer = _a.footer, empty = _a.empty, filter = _a.filter, pagination = _a.pagination, preferences = _a.preferences, _c = _a.items, items = _c === void 0 ? [] : _c, columnDefinitions = _a.columnDefinitions, trackBy = _a.trackBy, loading = _a.loading, loadingText = _a.loadingText, selectionType = _a.selectionType, _d = _a.selectedItems, selectedItems = _d === void 0 ? [] : _d, isItemDisabled = _a.isItemDisabled, ariaLabels = _a.ariaLabels, onSelectionChange = _a.onSelectionChange, onSortingChange = _a.onSortingChange, sortingColumn = _a.sortingColumn, sortingDescending = _a.sortingDescending, sortingDisabled = _a.sortingDisabled, visibleColumns = _a.visibleColumns, stickyHeader = _a.stickyHeader, stickyHeaderVerticalOffset = _a.stickyHeaderVerticalOffset, onRowClick = _a.onRowClick, onRowContextMenu = _a.onRowContextMenu, wrapLines = _a.wrapLines, resizableColumns = _a.resizableColumns, onColumnWidthsChange = _a.onColumnWidthsChange, _e = _a.variant, variant = _e === void 0 ? 'container' : _e, __internalRootRef = _a.__internalRootRef, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef"]);
    var baseProps = getBaseProps(rest);
    stickyHeader = stickyHeader && supportsStickyPosition();
    var _f = useContainerQuery(function (_a) {
        var width = _a.width;
        return width;
    }), containerWidth = _f[0], wrapperRef = _f[1];
    var secondaryWrapperRef = React.useRef(null);
    var tableRef = useRef(null);
    var theadRef = useRef(null);
    var stickyHeaderRef = React.useRef(null);
    var scrollbarRef = React.useRef(null);
    useImperativeHandle(ref, function () { var _a; return ({ scrollToTop: ((_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop) || (function () { return undefined; }) }); });
    var handleScroll = useScrollSync([wrapperRef, scrollbarRef, secondaryWrapperRef], !supportsStickyPosition());
    var _g = useFocusMove(selectionType, items.length), moveFocusDown = _g.moveFocusDown, moveFocusUp = _g.moveFocusUp, moveFocus = _g.moveFocus;
    var _h = useRowEvents({ onRowClick: onRowClick, onRowContextMenu: onRowContextMenu }), onRowClickHandler = _h.onRowClickHandler, onRowContextMenuHandler = _h.onRowContextMenuHandler;
    var visibleColumnDefinitions = visibleColumns
        ? columnDefinitions.filter(function (column) { return column.id && visibleColumns.indexOf(column.id) !== -1; })
        : columnDefinitions;
    var _j = useSelection({
        items: items,
        trackBy: trackBy,
        selectedItems: selectedItems,
        selectionType: selectionType,
        isItemDisabled: isItemDisabled,
        onSelectionChange: onSelectionChange,
        ariaLabels: ariaLabels
    }), isItemSelected = _j.isItemSelected, selectAllProps = _j.selectAllProps, getItemSelectionProps = _j.getItemSelectionProps, updateShiftToggle = _j.updateShiftToggle;
    if (loading) {
        selectAllProps.disabled = true;
    }
    if (isDevelopment) {
        if (resizableColumns) {
            checkColumnWidths(columnDefinitions);
        }
        if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
            checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
        }
    }
    var isRefresh = useVisualRefresh(tableRef);
    var computedVariant = isRefresh
        ? variant
        : ['embedded', 'full-page'].indexOf(variant) > -1
            ? 'container'
            : variant;
    var hasHeader = !!(header || filter || pagination || preferences);
    var theadProps = {
        containerWidth: containerWidth,
        selectionType: selectionType,
        selectAllProps: selectAllProps,
        columnDefinitions: visibleColumnDefinitions,
        variant: computedVariant,
        wrapLines: wrapLines,
        resizableColumns: resizableColumns,
        sortingColumn: sortingColumn,
        sortingDisabled: sortingDisabled,
        sortingDescending: sortingDescending,
        onSortingChange: onSortingChange,
        onFocusMove: moveFocus,
        onResizeFinish: function (newWidth) {
            var widthsDetail = columnDefinitions.map(function (column, index) { return newWidth[getColumnKey(column, index)] || column.width || DEFAULT_WIDTH; });
            var widthsChanged = widthsDetail.some(function (width, index) { return columnDefinitions[index].width !== width; });
            if (widthsChanged) {
                fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
            }
        }
    };
    return (React.createElement(ColumnWidthsProvider, { tableRef: tableRef, visibleColumnDefinitions: visibleColumnDefinitions, resizableColumns: resizableColumns, hasSelection: !!selectionType },
        React.createElement(InternalContainer, __assign({}, baseProps, { __internalRootRef: __internalRootRef, className: clsx(baseProps.className, styles.root), header: React.createElement(React.Fragment, null,
                hasHeader && (React.createElement("div", { className: clsx(styles['header-controls'], styles["variant-" + computedVariant]) },
                    React.createElement(ToolsHeader, { header: header, filter: filter, pagination: pagination, preferences: preferences }))),
                stickyHeader && (React.createElement(StickyHeader, { ref: stickyHeaderRef, variant: computedVariant, theadProps: theadProps, wrapperRef: wrapperRef, theadRef: theadRef, secondaryWrapperRef: secondaryWrapperRef, onScroll: handleScroll }))), disableHeaderPaddings: true, disableContentPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterPaddings: true, __disableFooterDivider: true, footer: footer && (React.createElement("div", { className: clsx(styles['footer-wrapper'], styles["variant-" + computedVariant]) },
                React.createElement("hr", { className: styles.divider }),
                React.createElement("div", { className: styles.footer }, footer))), __stickyHeader: stickyHeader, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
            React.createElement("div", { ref: wrapperRef, className: clsx(styles.wrapper, styles["variant-" + computedVariant], (_b = {},
                    _b[styles['has-footer']] = !!footer,
                    _b[styles['has-header']] = hasHeader,
                    _b)), onScroll: handleScroll },
                React.createElement("table", { ref: tableRef, className: clsx(styles.table, resizableColumns && styles['table-layout-fixed']), role: "table" },
                    React.createElement(Thead, __assign({ ref: theadRef, hidden: stickyHeader, onCellFocus: function (colIndex) { var _a; return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(colIndex); }, onCellBlur: function () { var _a; return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(null); } }, theadProps)),
                    React.createElement("tbody", null, loading || items.length === 0 ? (React.createElement("tr", null,
                        React.createElement("td", { colSpan: selectionType ? visibleColumnDefinitions.length + 1 : visibleColumnDefinitions.length, className: styles['cell-merged'] },
                            React.createElement("div", { className: styles['cell-merged-content'], style: {
                                    width: (supportsStickyPosition() && containerWidth && Math.floor(containerWidth)) || undefined
                                } }, loading ? (React.createElement(InternalStatusIndicator, { type: "loading", className: styles.loading }, loadingText)) : (React.createElement("div", { className: styles.empty }, empty)))))) : (items.map(function (item, rowIndex) {
                        var _a;
                        var lastVisible = rowIndex === items.length - 1;
                        var isNextSelected = selectionType && !lastVisible && isItemSelected(items[rowIndex + 1]);
                        var isSelected = selectionType && isItemSelected(item);
                        return (React.createElement("tr", __assign({ key: getItemKey(trackBy, item, rowIndex), className: clsx(styles.row, (_a = {},
                                _a[styles['row-selected']] = isSelected,
                                _a[styles['next-row-selected']] = isNextSelected,
                                _a)), onFocus: function (_a) {
                                var _b;
                                var currentTarget = _a.currentTarget;
                                return (_b = stickyHeaderRef.current) === null || _b === void 0 ? void 0 : _b.scrollToRow(currentTarget);
                            } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item) }),
                            selectionType !== undefined && (React.createElement(SelectionControl, __assign({ className: clsx(styles.cell, styles['body-cell'], styles['selection-control']), onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, onShiftToggle: updateShiftToggle }, getItemSelectionProps(item)))),
                            visibleColumnDefinitions.map(function (column, colIndex) { return (React.createElement("td", { key: getColumnKey(column, colIndex), style: resizableColumns
                                    ? {}
                                    : {
                                        width: column.width,
                                        minWidth: column.minWidth,
                                        maxWidth: column.maxWidth
                                    }, className: clsx(styles.cell, styles['body-cell'], wrapLines && styles['body-cell-wrap']) }, column.cell(item))); })));
                    })))),
                resizableColumns && React.createElement(ResizeTracker, null)),
            React.createElement(StickyScrollbar, { ref: scrollbarRef, wrapperRef: wrapperRef, tableRef: tableRef, onScroll: handleScroll }))));
});
export default InternalTable;
